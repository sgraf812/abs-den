\section{Abstract Interpretation}
\label{sec:abstractions}

\subsection{Lazy Denotational Deadness}

Let us first try to reformulate semantic deadness in terms of $\semevt{\wild}$
and $\equiv$:

\begin{definition}[Denotational deadness, lazily]
  \label{defn:deadness3}
  An address $\pa$ is \emph{dead} in a denotation $d$ if and only if,
  for all $μ_1 \approx μ_2$ such that $\pa$ is dead in $\rng(μ_i)$,
  $\dom(μ_1) ∪ \{\pa\} ⊦ d$ and $d_1,d_2$, we have
  \[
    \dom(μ_1) ⊦ d(μ_1[\pa↦d_1]) \sim d(μ_2[\pa↦d_2]).
  \]
  A variable $\px$ is \emph{dead} in an expression $\pe$ if and only
  if, for all $ρ ∈ \Var \to \EventD, \pe_1,\pe_2 ∈ \Exp$, we have
  \[\semevt{\Let{\px}{\pe_1}{\pe}}_{ρ} \equiv \semevt{\Let{\px}{\pe_2}{\pe}}_{ρ}.\]
  Otherwise, $\px$ is \emph{live}.
\end{definition}

If $x$ is dead in $\pe_2$ according to this definition, then we can justify the
following rewrite:
\[
  \Let{x}{\pe_1}{\pe_2} \equiv \Let{x}{\mathit{crash}}{\pe_2}
\]
A syntactic \emph{occurrence analysis} could subsequently figure out whether the
binding for $x$ can be dropped without introducing scoping errors.

We can now prove \Cref{thm:semusg-correct-live} in terms of this new
characterisation of deadness by induction:

\begin{theorem}[$\semusg{\wild}$ is a correct deadness analysis]
  \label{thm:semusg-correct-live-3}
  Let $\pe$ be an expression, $\px$ a variable and $\tr$ a usage environment.
  If $\tr(\px) \not⊑ \semusg{\pe}_{\tr}$
  then $\px$ is dead in $\pe$.
\end{theorem}
\begin{proof}
  By induction over $\pe$.
  The full proof can be found in \Cref{prf:semusg-correct-live-3}.
\end{proof}

\subsubsection*{Discussion}

The main proof of \Cref{thm:semusg-correct-live-3} is hardly longer than
\Cref{thm:semusg-correct-live}, but we have to admit that we needed to prove
quite a few metatheoretic properties to get there, so we declare only partial
victory on Goal 1 from \Cref{sec:problem}.
For obvious reasons, it seems preferable to stick to a simpler call-by-name
semantics without a heap if the property in question (\eg, deadness) can be
understood there as well.

Still, with \Cref{defn:deadness3} we were at least able to break
down the proof into manageable intermediate steps.
That is a huge step forward compares to the operational deadness definition of
\Cref{defn:deadness2} where we weren't even able to come up with a suitable
correctness relation.

In hindsight, we could trace back the intermediate steps to come up with at
least one proof strategy with \Cref{defn:deadness2}:
The structural induction principle is an important enabling factor and
the focus on maximal traces in \Cref{fig:semst-correctness} suggests that
we should likely strive for a correctness relation characterising a property of
maximal traces.
This was not obvious to us when we first set out to do the proof; the gap was
too large to see how to get to the other side due to the structural mismatch.
A nice consequence of successfully avoiding structural mismatch, which we set
out to in Goal 4.

\subsection{Evaluation Cardinality}

Since our new semantics is able to express evaluation cardinality and thunk
update, we can try to add a new $\mathbf{let1}$ construct to our language that
opts out of memoisation:
\[
 \begin{array}{rcl}
  \derefn(\pa)(μ)   & = & \LookupA(\pa) \cons μ(\pa)(μ) \\
  \\[-0.5em]
  \semevt{\Letn{\px}{\pe_1}{\pe_2}}_ρ(μ) & = &
    \begin{letarray}
      \text{let} & ρ' = ρ[\px ↦ \highlight{\derefn(\pa)}] \quad \text{where $\pa \not∈ \dom(μ)$} \\
                 & d_1^\later = \semevt{\pe_1}_{ρ'} \\
      \text{in}  & \BindA(\px,\pa↦d_1^\later) \cons \semevt{\pe_2}_{ρ'}(μ[\pa ↦ d_1^\later])
    \end{letarray} \\
 \end{array}
\]
Any program in which we switch from memoised $\mathbf{let}$ to $\mathbf{let1}$
is semantically equivalent.
This is a simple consequence of the fact that $\deref(\pa) \equiv \derefn(\pa)$
and compositionality.

However, omitting thunk memoisation has measurable effect on performance
if the same variable is evaluated repeatedly!

\begin{figure}
\[\begin{array}{c}
 \ruleform{ \fin(τ) \qquad A ⊦ d \qquad A ⊦ τ_1 \sim τ_2 \qquad μ_1 \approx μ_2 \qquad d_1 \equiv d_2}
 \\
 \\[-0.5em]
 \inferrule*[right=\eqlrcons]
    {\later (A ⊦_n τ_1 \sim τ_2)}
    {A ⊦_n \wild \cons τ_1 \sim \wild \cons τ_2}
 \quad
 \inferrule*[right=\eqrcons]
    {A ⊦_n τ_1 \sim τ_2 \quad n < ω}
    {A ⊦_{n+1} τ_1 \sim \wild \cons τ_2}
 \quad
 \inferrule*[right=\eqlcons]
    {A ⊦_{n+1} τ_1 \sim τ_2 \quad n < ω}
    {A ⊦_{n} \wild \cons τ_1 \sim τ_2}
 \\
 \\[-0.5em]
 \inferrule*[right=\eqstuck]
    {\quad}
    {A ⊦_{0} \stuckend{} \sim \stuckend{}}
 \quad
 \inferrule*[right=\eqcon]
    {\later (A ⊦_{n} \many{d_1(μ_1) \sim d_2(μ_2)})}
    {A ⊦_{0} \goodend{\ConV(K, \many{d_1}), μ_1} \sim \goodend{\ConV(K, \many{d_2}), μ_2}}
 \\
 \\[-0.5em]
 \inferrule*[right=\eqfun]
    {\forall d.\ A ⊦ d ⟹  A ⊦_{n} f_1(d)(μ_1) \sim f_2(d)(μ_2)}
    {A ⊦_{0} \goodend{\FunV(f_1), μ_1} \sim \goodend{\FunV(f_2), μ_2}}
 \\
 \\[-0.5em]
 \inferrule*[right=\eqheap]
    {\dom(μ_1) = \dom(μ_2) \quad \forall \pa.\ \later(\dom(μ_1) ⊦ μ_1(\pa)(μ_1) \sim μ_2(\pa)(μ_2))}
    {μ_1 \approx μ_2}
 \\
 \\[-0.5em]
 \inferrule*[right=\eqdenot]
    {\forall μ_1,μ_2.\ μ_1 \approx μ_2 \wedge  \dom(μ_1) ⊦ d_1,d_2 ⟹  \dom(μ_1) ⊦_n d_1(μ_1) \sim d_2(μ_2)}
    {d_1 \equiv d_2}
\end{array}\]
\caption{Improvement relation}
  \label{fig:sem-equiv}
\end{figure}


\begin{figure}
\[\begin{array}{c}
  \forall \tr.\ \tr(x) ⊑ \semusg{\pe}_{\tr} \\
  \Uparrow \\
  \exists \tr,\td_1,\td_2.\ \semusg{\pe}_{\tr[x ↦ \td_1]} \not= \semusg{\pe}_{\tr[x ↦ \td_2]} \\
  \Uparrow \text{ This one is non-trivial, but we can take any $α(d_1),α(d_2)$ and add $[x_1↦1],[x_2↦1]$ for some "fresh" vars}\\
  \exists ρ,d_1,d_2,ι_1,ι_2.\ \semevt{\pe}_{ρ[x ↦ d_1]}(ι_1) \not= \semevt{\pe}_{ρ[x ↦ d_2]}(ι_2) \\
  \Uparrow \\
  \exists \pe_1,\pe_2.\ \semevt{\Let{x}{\pe_1}{\pe}} \not= \semevt{\Let{x}{\pe_2}{\pe}} \\
  \Updownarrow \\
  x \text{ live in } \pe \\
\end{array}\]

\[\begin{array}{c}
  \exists \tr.\ \tr(x) \not⊑ \semusg{\pe}_{\tr} \\
  \Downarrow \\
  \forall \tr,\td_1,\td_2.\ \semusg{\pe}_{\tr[x ↦ \td_1]} = \semusg{\pe}_{\tr[x ↦ \td_2]} \\
  \Downarrow \text{ This one is non-trivial, but we can take any $α(d_1),α(d_2)$ and add $[x_1↦1],[x_2↦1]$ for some "fresh" vars}\\
  \forall ρ,d_1,d_2,ι_1,ι_2.\ \semevt{\pe}_{ρ[x ↦ d_1]}(ι_1) = \semevt{\pe}_{ρ[x ↦ d_2]}(ι_2) \\
  \Downarrow \\
  \forall \pe_1,\pe_2.\ \semevt{\Let{x}{\pe_1}{\pe}} = \semevt{\Let{x}{\pe_2}{\pe}} \\
  \Updownarrow \\
  x \text{ dead in } \pe \\
\end{array}\]

\[\begin{array}{c}
 \begin{array}{rcl}
  \multicolumn{3}{c}{ \ruleform{ defn : \Traces \to (\Addresses \pfun \Var) \qquad blub : \Traces \to (\Var \to \UsgD) \to (\Addresses \to \UsgD) } } \\
  \\[-0.5em]
  defn_{\Traces}(a \cons τ) & = & defn(a) \uplus defn(τ) \\
  defn_{\Events}(\BindA(\px,\pa↦\pe,d)) & = & [\pa↦\px] \\
  blub(τ)(\tr)(\pa) & = & \tr(defn_{\Traces}(τ)(\pa)) \text{ or $\bot$} \\
  \\[-0.5em]
  \multicolumn{3}{c}{ \ruleform{ usg : (\Addresses \to \UsgD) \to \Traces \to \UsgD \times \Values{\UsgD} } } \\
  \\[-0.5em]
  usg_{\Traces}(\tm)(\goodend{\FunV(f)}) & = & (\fn{\wild}{0}, α_{\Values{}}(\FunV(f))) \\
  usg_{\Traces}(\tm)(\stuckend{}) & = & (\fn{\wild}{0}, \bot_{\Values{\UsgD}}) \\
  usg_{\Traces}(\tm)(\pe \act{a} τ) & = & usg_{\Events}(\tm)(a) +_1 usg_{\Traces}(\tm)(τ) \\
  usg_{\Events}(\tm)(a) & = & \begin{cases}
      \tm(\pa) & a = \LookupT(\pa) \\
      0 & \text{otherwise}
    \end{cases} \\
  usg^{-1}_{\Traces}(\tm)(\goodend{(\lbl, \FunV(f))}) & = & (0, α_{\Values{}}(\FunV(f))) \\
  usg_{\EventD}(\tm)(d) & = & usg_{\Traces} \circ d \circ usg^{-1}_{\Traces} \\
  usg^{-1}_{\EventD}(\tm)(d) & = & usg^{-1}_{\Traces} \circ d \circ usg_{\Traces} \\
  usg_{\Values{}}(\tm)(\FunV(f)) & = & \FunV(usg_{\EventD} \circ f \circ usg^{-1}_{\EventD}) \\
  \\[-0.5em]
  \multicolumn{3}{c}{ \ruleform{ intra : \UsgD \times \Values{\UsgD} \to \UsgD \times \Values{\UsgD} } } \\
  \\[-0.5em]
  intra(d, \FunV(f)) & = & (d + ω*f(\bot), \FunV(\fn{d}{ω*d})) \\
  \\[-0.5em]
  \multicolumn{3}{c}{ \ruleform{ α : \Traces \to \UsgD } } \\
  \\[-0.5em]
  α(τ) & = & fst(intra(usg_\Traces(blub(τ)(\fn{\px}{[\px↦1]}))(τ))) \\
 \end{array}
\end{array}\]
\end{figure}
