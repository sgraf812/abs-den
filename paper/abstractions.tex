\section{Abstract Interpretation}
\label{sec:abstractions}

\subsection{Lazy Denotational Deadness}

Let us first try to reformulate semantic deadness in terms of $\semevt{\wild}$:

\begin{definition}[Denotational deadness, lazily and unusable]
  \label{defn:deadness3}
  A variable $\px$ is \emph{dead} in an expression $\pe$ if and only
  if, for all $ρ ∈ \Var \to \EventD, d_1, d_2 ∈ \EventD, μ ∈ \Heaps$ and $\pa ∈ \Addresses$ such that $ρ(\px) = \deref(\pa)$, we have
  \[\semevt{\pe}_{ρ}(μ[\pa ↦ d_1]) = \semevt{\pe}_{ρ}(μ[\pa ↦ d_2]).\]
  Otherwise, $\px$ is \emph{live}.
\end{definition}

Alas, this definition is vacuously true!
We can observe distinct $d_1,d_2$ in the entry $μ(\pa)$ listed in the final heap
$μ$ of a trace ending in $\goodend{v,μ}$.
Furthermore, there is no guarantee that some other entry in $ρ$ besides $ρ(\px)$
might dereference $\pa$.

It is reasonable to \emph{restrict} what we can observe then in order to get
a coarser equivalence relation than definitional equality on traces.
For example, we could compare traces modulo the kernel of the length function
such as defined in \Cref{thm:abs-length}.

Alas, the equivalence relation induced in this way would be \emph{too} coarse:
Consider $(\Lam{x}{y})$; this expression would be dead in $y$ according to that
definition because all its maximal traces will have length 1.
But clearly we should not be able to rewrite $\Let{y}{\pe}{\Lam{x}{y}}$ to
$\Let{y}{\mathit{crash}}{\Lam{x}{y}}$, the latter of which would crash when
applied to an argument.
So our equivalence relation must be finer on values, just like observational
equivalence in operational semantics.

The key is to introduce an equivalence relation on heaps with a ``blind spot''
concerning the contents of address $\pa$ (we will define $\dead^{\EventD}_\pa$
momentarily):%
\footnote{This is nearly the correctness predicate $\sim_V$ of
\citet[Theorem 2.21]{Nielson:99}.
The only conceptual difference is that $V$ tracks the set of \emph{live} variables,
whereas we track a single address assumed to be \emph{dead}.}
\[
 \inferrule*
    {\pa ∈ \dom(μ_1) ∩ \dom(μ_2) \quad \forall \pa' ∈ (\dom(μ_1) \setminus \{ \pa \}).\ μ_1(\pa') = μ_2(\pa') \wedge \dead^{\EventD}_\pa(μ_1(\pa')) }
    {μ_1 \sim^{\Heaps{}}_{\pa} μ_2}
\]
Now we lift this equivalence relation congruently over $\Traces$ and define a
predicate aptly named $\dead_{\pa}$ over $\Events$, $\EventD$ and $\EventV$ that carves
out the subsets we will consider $\pa$ dead in.
For $\Events$ we only give the rule concerning the $\AppEA$ event as an example:%
\footnote{These definitions are to be understood as coinductive, although we omit distracting $\later$.}
\[\begin{array}{cc}
 \begin{array}{c}
 \inferrule*
    {\dead^{\Events}_{\pa}(ε) \quad τ_1 \sim^{\Traces}_{\pa} τ_2}
    {ε \cons τ_1 \sim^{\Traces}_{\pa} ε \cons τ_2}
 \qquad
 \inferrule*
    {\quad}
    {\stuckend{} \sim^{\Traces}_{\pa} \stuckend{}}
 \qquad
 \inferrule*
    {\dead^{\EventV}_{\pa}(v) \quad μ_1 \sim^{\Heaps}_{\pa} μ_2}
    {\goodend{v,μ_1} \sim^{\Traces}_{\pa} \goodend{v,μ_2}}
 \\
 \\[-0.5em]
 \inferrule*[right=\ldots]
    {\dead^{\EventD}_{\pa}(d)}
    {\dead^{\Events}(\AppEA(\px ↦ d))}
 \qquad
 \inferrule*
    {\forall μ_1, μ_2.\ μ_1 \sim^{\Heaps}_{\pa} μ_2 \Longrightarrow d(μ_1) \sim^{\Traces}_{\pa} d(μ_2) }
    {\dead^{\EventD}_{\pa}(d)}
 \\
 \\[-0.5em]
 \inferrule*
    {\many{\dead^{\EventD}_{\pa}(d)}}
    {\dead^{\EventV}_{\pa}(\ConV(K, \many{d}))}
 \qquad
 \inferrule*
    {\forall d.\ \dead^{\EventD}(d) \Longrightarrow \dead^{\EventD}(f(d))}
    {\dead^{\EventV}_{\pa}(\FunV(f))}
 \end{array}
\end{array}\]
The congruence rule for $\sim^{\EventD}_{\pa}$ is particularly interesting:
It expresses both an \emph{assumption} about the kind of heaps $μ_i$ passed
to $d$ as well as a \emph{requirement} on the trace resulting from applying
said heaps to $d$.
We can now formulate a useful notion of deadness in terms of this equivalence
relation:
\begin{definition}[Denotational deadness, lazily and useful]
  \label{defn:deadness4}
  An address $\pa$ is \emph{dead} in an element $d ∈ \EventD$
  if and only if $\dead^{\EventD}_{\pa}(d)$.
  Otherwise, $\pa$ is \emph{live} in $d$.

  Furthermore, a variable $\px$ is \emph{dead} in an expression $\pe$
  if and only if, for all $ρ ∈ \Var \to \EventD$ and addresses $\pa$ such that $\pa$ is dead in $\rng(ρ)$,
  $\pa$ is dead in $\semevt{\pe}_{ρ[\px ↦ \deref(\pa)]}$.
  Otherwise, $\px$ is \emph{live} in $\pe$.
\end{definition}
If $x$ is dead in $\pe_2$ according to this definition, then we can justify the
following rewrite if we choose not to observe heaps:
\[\arraycolsep=3pt
\begin{array}{lclcl}
\semevt{\Let{x}{\pe_1}{\pe_2}}_ρ(μ)
& = & \semevt{\pe_2}_{ρ[x↦\deref(\pa)]}(μ[\pa↦d])
\\
& \sim^{\Traces}_{\pa} & \semevt{\pe_2}_{ρ[x↦\deref(\pa)]}(μ[\pa↦\fn{\wild}{\stuckend{}}])
& = & \semevt{\Let{x}{\mathit{crash}}{\pe_2}}_ρ(μ)
\end{array}
\]
A syntactic \emph{occurrence analysis} could subsequently figure out whether the
binding for $x$ can be dropped without introducing scoping errors.

We can now prove \Cref{thm:semusg-correct-live} in terms of this new
characterisation of deadness by induction:

\begin{theorem}[$\semusg{\wild}$ is a correct deadness analysis]
  \label{thm:semusg-correct-live-3}
  Let $\pe$ be an expression, $\px$ a variable and $\tr$ a usage environment.
  If $\tr(\px) \not⊑ \semusg{\pe}_{\tr}$
  then $\px$ is dead in $\pe$.
\end{theorem}
\begin{proof}
  By induction over $\pe$. The full proof can be found in
  \Cref{prf:semusg-correct-live-3}.
\end{proof}

So that is nice.
Unfortunately, we have made no progress towards

\begin{figure}
\[\begin{array}{c}
  \forall \tr.\ \tr(x) ⊑ \semusg{\pe}_{\tr} \\
  \Uparrow \\
  \exists \tr,\td_1,\td_2.\ \semusg{\pe}_{\tr[x ↦ \td_1]} \not= \semusg{\pe}_{\tr[x ↦ \td_2]} \\
  \Uparrow \text{ This one is non-trivial, but we can take any $α(d_1),α(d_2)$ and add $[x_1↦1],[x_2↦1]$ for some "fresh" vars}\\
  \exists ρ,d_1,d_2,ι_1,ι_2.\ \semevt{\pe}_{ρ[x ↦ d_1]}(ι_1) \not= \semevt{\pe}_{ρ[x ↦ d_2]}(ι_2) \\
  \Uparrow \\
  \exists \pe_1,\pe_2.\ \semevt{\Let{x}{\pe_1}{\pe}} \not= \semevt{\Let{x}{\pe_2}{\pe}} \\
  \Updownarrow \\
  x \text{ live in } \pe \\
\end{array}\]

\[\begin{array}{c}
  \exists \tr.\ \tr(x) \not⊑ \semusg{\pe}_{\tr} \\
  \Downarrow \\
  \forall \tr,\td_1,\td_2.\ \semusg{\pe}_{\tr[x ↦ \td_1]} = \semusg{\pe}_{\tr[x ↦ \td_2]} \\
  \Downarrow \text{ This one is non-trivial, but we can take any $α(d_1),α(d_2)$ and add $[x_1↦1],[x_2↦1]$ for some "fresh" vars}\\
  \forall ρ,d_1,d_2,ι_1,ι_2.\ \semevt{\pe}_{ρ[x ↦ d_1]}(ι_1) = \semevt{\pe}_{ρ[x ↦ d_2]}(ι_2) \\
  \Downarrow \\
  \forall \pe_1,\pe_2.\ \semevt{\Let{x}{\pe_1}{\pe}} = \semevt{\Let{x}{\pe_2}{\pe}} \\
  \Updownarrow \\
  x \text{ dead in } \pe \\
\end{array}\]

\[\begin{array}{c}
 \begin{array}{rcl}
  \multicolumn{3}{c}{ \ruleform{ defn : \Traces \to (\Addresses \pfun \Var) \qquad blub : \Traces \to (\Var \to \UsgD) \to (\Addresses \to \UsgD) } } \\
  \\[-0.5em]
  defn_{\Traces}(a \cons τ) & = & defn(a) \uplus defn(τ) \\
  defn_{\Events}(\BindA(\px,\pa↦\pe,d)) & = & [\pa↦\px] \\
  blub(τ)(\tr)(\pa) & = & \tr(defn_{\Traces}(τ)(\pa)) \text{ or $\bot$} \\
  \\[-0.5em]
  \multicolumn{3}{c}{ \ruleform{ usg : (\Addresses \to \UsgD) \to \Traces \to \UsgD \times \Values{\UsgD} } } \\
  \\[-0.5em]
  usg_{\Traces}(\tm)(\goodend{\FunV(f)}) & = & (\fn{\wild}{0}, α_{\Values{}}(\FunV(f))) \\
  usg_{\Traces}(\tm)(\stuckend{}) & = & (\fn{\wild}{0}, \bot_{\Values{\UsgD}}) \\
  usg_{\Traces}(\tm)(\pe \act{a} τ) & = & usg_{\Events}(\tm)(a) +_1 usg_{\Traces}(\tm)(τ) \\
  usg_{\Events}(\tm)(a) & = & \begin{cases}
      \tm(\pa) & a = \LookupT(\pa) \\
      0 & \text{otherwise}
    \end{cases} \\
  usg^{-1}_{\Traces}(\tm)(\goodend{(\lbl, \FunV(f))}) & = & (0, α_{\Values{}}(\FunV(f))) \\
  usg_{\EventD}(\tm)(d) & = & usg_{\Traces} \circ d \circ usg^{-1}_{\Traces} \\
  usg^{-1}_{\EventD}(\tm)(d) & = & usg^{-1}_{\Traces} \circ d \circ usg_{\Traces} \\
  usg_{\Values{}}(\tm)(\FunV(f)) & = & \FunV(usg_{\EventD} \circ f \circ usg^{-1}_{\EventD}) \\
  \\[-0.5em]
  \multicolumn{3}{c}{ \ruleform{ intra : \UsgD \times \Values{\UsgD} \to \UsgD \times \Values{\UsgD} } } \\
  \\[-0.5em]
  intra(d, \FunV(f)) & = & (d + ω*f(\bot), \FunV(\fn{d}{ω*d})) \\
  \\[-0.5em]
  \multicolumn{3}{c}{ \ruleform{ α : \Traces \to \UsgD } } \\
  \\[-0.5em]
  α(τ) & = & fst(intra(usg_\Traces(blub(τ)(\fn{\px}{[\px↦1]}))(τ))) \\
 \end{array}
\end{array}\]
\end{figure}

\begin{itemize}
  \item Correctness predicate simpler to come up than for liveness analysis directly. Later
\end{itemize}
