\section{Abstract Interpretation}
\label{sec:abstractions}

\subsection{Lazy Denotational Deadness}

Let us first try to reformulate semantic deadness in terms of $\semevt{\wild}$:

\begin{definition}[Denotational deadness, lazily and unusable]
  \label{defn:deadness3}
  A variable $\px$ is \emph{dead} in an expression $\pe$ if and only
  if, for all $ρ ∈ \Var \to \EventD, d_1, d_2 ∈ \EventD, μ ∈ \Heaps$ and $\pa ∈ \Addresses$ such that $ρ(\px) = \deref(\pa)$, we have
  \[\semevt{\pe}_{ρ}(μ[\pa ↦ d_1]) = \semevt{\pe}_{ρ}(μ[\pa ↦ d_2]).\]
  Otherwise, $\px$ is \emph{live}.
\end{definition}

Alas, according to this definition, there are no dead variables!
We can observe distinct $d_1,d_2$ in the entry $μ(\pa)$ listed in the final heap
$μ$ of a trace ending in $\goodend{v,μ}$.
Furthermore, there is no guarantee that some other entry in $ρ$ besides $ρ(\px)$
might dereference $\pa$.

It is reasonable to \emph{restrict} what we can observe then in order to get a
coarser equivalence relation than definitional equality on the semantic domain.
For example, we could compare traces modulo the kernel of the length function
such as defined in \Cref{thm:abs-length}.
Unfortunately, the equivalence relation induced in this way would be \emph{too}
coarse, because it does not consider semantic values such as in the denotation
of $\Lam{\py}{\px}$.
Values in turn need access to the heap and we are back to discussing how to hide
internal heap partitions from the observer.

We just rediscovered the problem of full abstraction~\citep{Plotkin:77} which
first described the problems with definitional equality on semantic domains.
We do not intend to solve the problem here; suffice it to say that it got worse
by introducing a heap, because \Cref{defn:deadness} was a useful encoding of
deadness.

Instead we define the following contextual equivalence relation in terms of
evaluation contexts in the style of \citep{MoranSands:99} based on the $\len$
function in \Cref{thm:abs-length}.
For that we need syntax for evaluation contexts $E$ with holes $\hole$.
Then $E[\pe]$ denotes an expression where the hole in $E$ has been replaced with $\pe$.
\[\begin{array}{rcl}
  E & ::=  & \hole \mid E~\px \mid \Let{\px}{E}{E[\px]} \mid \Let{\px}{\pe}{E} \mid \Case{E}{\Sel[r]} \\
\end{array}\]
\begin{definition}
  \label{defn:ctx-equiv}
  For two expressions $\pe_1, \pe_2$ we say that $\pe_1$ is \emph{contextually
  equivalent} to $\pe_2$ (written $\pe_1 \approx_{\mathrm{C}} \pe_2$), if and only if
  for all closed contexts $E$, we have
  \[
    \len(\semevt{E[\pe_1]}_{[]}([])) = \len(\semevt{E[\pe_2]}_{[]}([]))
  \]
\end{definition}
\noindent
(This is not a satisfying solution to the full abstraction problem because it
involves quantification over all contexts $E$.)
Now we can give a useful definition of deadness:

\begin{definition}[Denotational deadness, contextually]
  \label{defn:deadness4}
  A variable $\px$ is \emph{dead} in an expression $\pe$ if and only
  if, for all expressions $\pe_1,\pe_2$, the expressions
  $\Let{\px}{\pe_1}{\pe}$ and $\Let{\px}{\pe_2}{\pe}$ are contextually
  equivalent.
\end{definition}

If $x$ is dead in $\pe_2$ according to this definition, then we can justify the
following rewrite:
\[
  \Let{x}{\pe_1}{\pe_2} \approx_{\mathrm{C}} \Let{x}{\mathit{crash}}{\pe_2}
\]
A syntactic \emph{occurrence analysis} could subsequently figure out whether the
binding for $x$ can be dropped without introducing scoping errors.

We can now prove \Cref{thm:semusg-correct-live} in terms of this new
characterisation of deadness by induction:

\begin{theorem}[$\semusg{\wild}$ is a correct deadness analysis]
  \label{thm:semusg-correct-live-3}
  Let $\pe$ be an expression, $\px$ a variable and $\tr$ a usage environment.
  If $\tr(\px) \not⊑ \semusg{\pe}_{\tr}$
  then $\px$ is dead in $\pe$.
\end{theorem}
\begin{proof}
  By induction over $\pe$ and then on the size of the evaluation context $E$.
  The full proof can be found in \Cref{prf:semusg-correct-live-3}.
\end{proof}

We have to admit that this turned out more complex than
\Cref{thm:semusg-correct-live}, but at least it was possible.

\begin{figure}
\[\begin{array}{c}
  \forall \tr.\ \tr(x) ⊑ \semusg{\pe}_{\tr} \\
  \Uparrow \\
  \exists \tr,\td_1,\td_2.\ \semusg{\pe}_{\tr[x ↦ \td_1]} \not= \semusg{\pe}_{\tr[x ↦ \td_2]} \\
  \Uparrow \text{ This one is non-trivial, but we can take any $α(d_1),α(d_2)$ and add $[x_1↦1],[x_2↦1]$ for some "fresh" vars}\\
  \exists ρ,d_1,d_2,ι_1,ι_2.\ \semevt{\pe}_{ρ[x ↦ d_1]}(ι_1) \not= \semevt{\pe}_{ρ[x ↦ d_2]}(ι_2) \\
  \Uparrow \\
  \exists \pe_1,\pe_2.\ \semevt{\Let{x}{\pe_1}{\pe}} \not= \semevt{\Let{x}{\pe_2}{\pe}} \\
  \Updownarrow \\
  x \text{ live in } \pe \\
\end{array}\]

\[\begin{array}{c}
  \exists \tr.\ \tr(x) \not⊑ \semusg{\pe}_{\tr} \\
  \Downarrow \\
  \forall \tr,\td_1,\td_2.\ \semusg{\pe}_{\tr[x ↦ \td_1]} = \semusg{\pe}_{\tr[x ↦ \td_2]} \\
  \Downarrow \text{ This one is non-trivial, but we can take any $α(d_1),α(d_2)$ and add $[x_1↦1],[x_2↦1]$ for some "fresh" vars}\\
  \forall ρ,d_1,d_2,ι_1,ι_2.\ \semevt{\pe}_{ρ[x ↦ d_1]}(ι_1) = \semevt{\pe}_{ρ[x ↦ d_2]}(ι_2) \\
  \Downarrow \\
  \forall \pe_1,\pe_2.\ \semevt{\Let{x}{\pe_1}{\pe}} = \semevt{\Let{x}{\pe_2}{\pe}} \\
  \Updownarrow \\
  x \text{ dead in } \pe \\
\end{array}\]

\[\begin{array}{c}
 \begin{array}{rcl}
  \multicolumn{3}{c}{ \ruleform{ defn : \Traces \to (\Addresses \pfun \Var) \qquad blub : \Traces \to (\Var \to \UsgD) \to (\Addresses \to \UsgD) } } \\
  \\[-0.5em]
  defn_{\Traces}(a \cons τ) & = & defn(a) \uplus defn(τ) \\
  defn_{\Events}(\BindA(\px,\pa↦\pe,d)) & = & [\pa↦\px] \\
  blub(τ)(\tr)(\pa) & = & \tr(defn_{\Traces}(τ)(\pa)) \text{ or $\bot$} \\
  \\[-0.5em]
  \multicolumn{3}{c}{ \ruleform{ usg : (\Addresses \to \UsgD) \to \Traces \to \UsgD \times \Values{\UsgD} } } \\
  \\[-0.5em]
  usg_{\Traces}(\tm)(\goodend{\FunV(f)}) & = & (\fn{\wild}{0}, α_{\Values{}}(\FunV(f))) \\
  usg_{\Traces}(\tm)(\stuckend{}) & = & (\fn{\wild}{0}, \bot_{\Values{\UsgD}}) \\
  usg_{\Traces}(\tm)(\pe \act{a} τ) & = & usg_{\Events}(\tm)(a) +_1 usg_{\Traces}(\tm)(τ) \\
  usg_{\Events}(\tm)(a) & = & \begin{cases}
      \tm(\pa) & a = \LookupT(\pa) \\
      0 & \text{otherwise}
    \end{cases} \\
  usg^{-1}_{\Traces}(\tm)(\goodend{(\lbl, \FunV(f))}) & = & (0, α_{\Values{}}(\FunV(f))) \\
  usg_{\EventD}(\tm)(d) & = & usg_{\Traces} \circ d \circ usg^{-1}_{\Traces} \\
  usg^{-1}_{\EventD}(\tm)(d) & = & usg^{-1}_{\Traces} \circ d \circ usg_{\Traces} \\
  usg_{\Values{}}(\tm)(\FunV(f)) & = & \FunV(usg_{\EventD} \circ f \circ usg^{-1}_{\EventD}) \\
  \\[-0.5em]
  \multicolumn{3}{c}{ \ruleform{ intra : \UsgD \times \Values{\UsgD} \to \UsgD \times \Values{\UsgD} } } \\
  \\[-0.5em]
  intra(d, \FunV(f)) & = & (d + ω*f(\bot), \FunV(\fn{d}{ω*d})) \\
  \\[-0.5em]
  \multicolumn{3}{c}{ \ruleform{ α : \Traces \to \UsgD } } \\
  \\[-0.5em]
  α(τ) & = & fst(intra(usg_\Traces(blub(τ)(\fn{\px}{[\px↦1]}))(τ))) \\
 \end{array}
\end{array}\]
\end{figure}

\begin{itemize}
  \item Correctness predicate simpler to come up than for liveness analysis directly. Later
\end{itemize}
