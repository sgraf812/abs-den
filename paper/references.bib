@inproceedings{Cousot-Cousot:POPL77,
  author = {Cousot, Patrick and Cousot, Radhia},
  title = {Abstract Interpretation: A Unified Lattice Model for Static Analysis of Programs by Construction or Approximation of Fixpoints},
  year = {1977},
  isbn = {9781450373500},
  publisher = {Association for Computing Machinery},
  address = {New York, NY, USA},
  url = {https://doi.org/10.1145/512950.512973},
  doi = {10.1145/512950.512973},
  abstract = {A program denotes computations in some universe of objects. Abstract interpretation of programs consists in using that denotation to describe computations in another universe of abstract objects, so that the results of abstract execution give some information on the actual computations. An intuitive example (which we borrow from Sintzoff [72]) is the rule of signs. The text -1515 * 17 may be understood to denote computations on the abstract universe {(+), (-), (±)} where the semantics of arithmetic operators is defined by the rule of signs. The abstract execution -1515 * 17 → -(+) * (+) → (-) * (+) → (-), proves that -1515 * 17 is a negative number. Abstract interpretation is concerned by a particular underlying structure of the usual universe of computations (the sign, in our example). It gives a summary of some facets of the actual executions of a program. In general this summary is simple to obtain but inaccurate (e.g. -1515 + 17 → -(+) + (+) → (-) + (+) → (±)). Despite its fundamentally incomplete results abstract interpretation allows the programmer or the compiler to answer questions which do not need full knowledge of program executions or which tolerate an imprecise answer, (e.g. partial correctness proofs of programs ignoring the termination problems, type checking, program optimizations which are not carried in the absence of certainty about their feasibility, …).},
  booktitle = {Proceedings of the 4th ACM SIGACT-SIGPLAN Symposium on Principles of Programming Languages},
  pages = {238–252},
  numpages = {15},
  location = {Los Angeles, California},
  series = {POPL '77}
}

@techreport{Scott:81,
  title = {LECTURES ON A MATHEMATICAL THEORY OF COMPUTATION},
  author = {Dana S. Scott},
  year = {1981},
  institution = {Department of Computer Science, University of Oxford},
  number = {PRG19},
  pages = {152},
}

@inproceedings{imprecise-exceptions,
  author = {Peyton Jones, Simon and Reid, Alastair and Henderson, Fergus and Hoare, Tony and Marlow, Simon},
  title = {A Semantics for Imprecise Exceptions},
  year = {1999},
  isbn = {1581130945},
  publisher = {Association for Computing Machinery},
  address = {New York, NY, USA},
  url = {https://doi.org/10.1145/301618.301637},
  doi = {10.1145/301618.301637},
  abstract = {Some modern superscalar microprocessors provide only imprecise exceptions. That is, they do not guarantee to report the same exception that would be encountered by a straightforward sequential execution of the program. In exchange, they offer increased performance or decreased chip area (which amount to much the same thing).This performance/precision tradeoff has not so far been much explored at the programming language level. In this paper we propose a design for imprecise exceptions in the lazy functional programming language Haskell. We discuss several designs, and conclude that imprecision is essential if the language is still to enjoy its current rich algebra of transformations. We sketch a precise semantics for the language extended with exceptions.The paper shows how to extend Haskell with exceptions without crippling the language or its compilers. We do not yet have enough experience of using the new mechanism to know whether it strikes an appropriate balance between expressiveness and performance.},
  booktitle = {Proceedings of the ACM SIGPLAN 1999 Conference on Programming Language Design and Implementation},
  pages = {25–36},
  numpages = {12},
  location = {Atlanta, Georgia, USA},
  series = {PLDI '99}
}

@book{DaveyPriestley:02,
  place={Cambridge},
  edition={2},
  title={Introduction to Lattices and Order},
  DOI={10.1017/CBO9780511809088},
  publisher={Cambridge University Press},
  author={Davey, B. A. and Priestley, H. A.},
  year={2002}
}

@article{Sestoft:97,
  title={Deriving a lazy abstract machine},
  volume={7},
  DOI={10.1017/S0956796897002712},
  number={3},
  journal={Journal of Functional Programming},
  publisher={Cambridge University Press},
  author={Sestoft, Peter},
  year={1997},
  pages={231–264}
}

@book{Nielson:99,
  author    = {Flemming Nielson and
               Hanne Riis Nielson and
               Chris Hankin},
  title     = {Principles of program analysis},
  publisher = {Springer},
  year      = {1999},
  url       = {https://doi.org/10.1007/978-3-662-03811-6},
  doi       = {10.1007/978-3-662-03811-6},
  isbn      = {978-3-540-65410-0},
  timestamp = {Tue, 16 May 2017 01:00:00 +0200},
  biburl    = {https://dblp.org/rec/books/daglib/0098888.bib},
  bibsource = {dblp computer science bibliography, https://dblp.org}
}

@book{Cousot:21,
  title={Principles of Abstract Interpretation},
  author={Cousot, Patrick},
  isbn={9780262044905},
  lccn={2020041256},
  url={https://mitpress.mit.edu/9780262044905/principles-of-abstract-interpretation/},
  year={2021},
  publisher={MIT Press}
}

@techreport{Scott:70,
  title = "Outline of a Mathematical Theory of Computation",
  author = "Dana Scott",
  year = "1970",
  institution = "OUCL",
  month = "November",
  number = "PRG02",
  pages = "30",
}

@techreport{ScottStrachey:71,
  title = "Toward a Mathematical Semantics for Computer Languages",
  author = "Dana Scott and Christopher Strachey",
  year = "1971",
  institution = "OUCL",
  month = "August",
  number = "PRG06",
  pages = "49",
}

@inproceedings{Shivers:91,
  author = {Shivers, Olin},
  title = {The Semantics of Scheme Control-Flow Analysis},
  year = {1991},
  isbn = {0897914333},
  publisher = {Association for Computing Machinery},
  address = {New York, NY, USA},
  url = {https://doi.org/10.1145/115865.115884},
  doi = {10.1145/115865.115884},
  booktitle = {Proceedings of the 1991 ACM SIGPLAN Symposium on Partial Evaluation and Semantics-Based Program Manipulation},
  pages = {190–198},
  numpages = {9},
  location = {New Haven, Connecticut, USA},
  series = {PEPM '91}
}
