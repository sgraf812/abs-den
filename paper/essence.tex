\section{The Imperative Essence of Memoisation}
\label{sec:essence}

Before we can talk about abstraction, we have to record a few meta-theoretic
properties.
We will prove these properties in terms of the eventful semantics but they apply
just the same for the stateful one, or even the ``bare-bones'' version from
the Appendix.

\subsection{Heap Forcing and Laziness}

As we have observed in \Cref{sec:problem}, the semantics of call-by-need is more
complicated than the semantics for call-by-name and call-by-value because it
relies on a heap to implement thunk memoisation.
This leads to a more complicated domain model that essentially passes around
heaps as state and exposes tiresome operational detail such as heap addresses.

On the other hand, memoisation is a very ``benign'' use of state and often we
can reason rather naturally about call-by-need programs without thinking too
much about heaps, in contrast to a calculus with arbitrary assignments to ref
cells.

For example, we can observe that heaps in our semantics evolve in a very
specific way:
When $\semevt{\pe}_ρ(μ) = ... \cons \goodend{v,μ'}$, we intuit that $μ'$ must be
``at least as evaluated'' as $μ$, \eg, for all $\pa ∈ \dom(μ)$ either $μ(\pa) =
μ'(\pa)$ or $μ'(\pa)$ is ``the value of'' $μ(\pa)$.
We make this observation precise via the following definitions:

\begin{definition}[Big-step]
  \label{defn:eval-d}
  For all $d ∈ \EventD$, $v ∈ \EventV$, $μ, μ' ∈ \Heaps$ we say that
  $d$ \emph{evaluates} in $μ$ to $(v,μ')$ (written $\bigstep{d}{μ}{v}{μ'}$) if
  and only if $d(μ) = ... \cons \goodend{v,μ'}$.
\end{definition}

Big-step notation deliberately throws away much information about the trace,
retaining only whether it was balanced and what the final value and heap is,
hence the name ``big-step'' is fitting.

\begin{definition}[Heap forcing]
  \label{defn:force-heap}
  For all $μ_1, μ_2 ∈ \Heaps$ we say that $μ_1$ \emph{forces} to $μ_2$
  (written $μ_1 \forcesto μ_2$) if and only if
  \begin{enumerate}
    \item $\dom(μ_1) ⊆ \dom(μ_2)$, and
    \item For all $\pa$, either
      \begin{itemize}
        \item $μ_1(\pa) = μ_2(\pa)$, or
        \item there exists $v,μ'_1$ such that
          $μ_2(\pa) = \ret(v)$ and $\bigstep{μ_1(\pa)}{μ_1}{v}{μ'_1}$.
          Additionally, if $μ_1 \not= μ'_1$ then  $μ'_1 \forcesto μ_2$.
      \end{itemize}
  \end{enumerate}
\end{definition}

(This is a well-formed inductive definition because $μ_1' \forcesto μ_2$
is strictly decreasing in the termination measure we give in the proof of
\Cref{defn:lazy-d}.)

Our earlier intuition can now be formulated as follows:
If $\bigstep{\semevt{\pe}_ρ}{μ}{v}{μ'}$, then $μ \forcesto μ'$.

For the remainder of this work, we will identify heaps modulo consistent
readdressing.
Of course, a rigorous treatment would have to carry around readdressing
substitutions and apply them to adjust the domain of a heap, its entries,
as well as the heaps, domain elements and values in the returned traces.
\sg{Perhaps I should give a figure with the definitions I have in mind, maybe
in the Appendix.}

%We write $μ_1 \forcessym μ_2$ if either $μ_1 \forcesto μ_2$ or
%$μ_2 \forcesto μ_1$ holds.
When a heap entry is evaluated, it stays that way during forcing:

\begin{lemma}
  \label{thm:force-heap-val}
  For all $μ_1,μ_2,\pa,v$ such that $μ_1 \forcesto μ_2$ and $μ_1(\pa) = \ret(v)$,
  then $μ_2(\pa) = \ret(v)$.
\end{lemma}
\begin{proof}
  Immediate proof by contraposition and unfolding of $\ret$.
\end{proof}

So once an entry becomes a value during forcing, it stays that way.

The heap forcing relation is reflexive (it is always $μ(\pa) = μ(\pa)$) and
also antisymmetric:

\begin{lemma}[$(\forcesto)$ is antisymmetric]
  \label{thm:force-heap-trans}
  Let $μ_1,μ_2$ be heaps and $μ_1 \forcesto μ_2, μ_2 \forcesto μ_1$.
  Then $μ_1 = μ_2$.
\end{lemma}
\begin{proof}
  It is easy to see that both $μ_1$ and $μ_2$ must have the same domain.

  Now suppose that there exists $\pa$ such that $μ_1(\pa) \not= μ_2(\pa)$.
  Then there exists $v_1$ such that $\bigstep{μ_1(\pa)}{μ_1}{v_1}{\wild}$ and
  $μ_2(\pa) = \ret(v_1)$.
  By \Cref{thm:force-heap-val} applied to $μ_2 \forcesto μ_1$, we get $μ_1(\pa)
  = v_1 = μ_2(\pa)$, a contradiction.
\end{proof}

(It is worth stressing that antisymmetry only holds on equivalence classes modulo readdressing.)
However, $(\forcesto)$ is not easily proven transitive without further
characterisation of the domain elements returned by $\semevt{\wild}$.

First off, we need to characterise the \emph{address domain} of a domain element $d$:

\begin{definition}[Address domain, trusting]
  An element $d$ is \emph{defined on} a set of addresses $A$ (written $A ⊦ d$) if and only if
  $d(μ)$ is defined on $A$ whenever $A ⊆ \dom(μ)$.\\
  A trace $τ$ is \emph{defined on} a set of addresses $A$ (written $A ⊦ τ$), if and only if
  $τ = ... \cons \goodend{v,μ}$ for some $v,μ$ implies
  \begin{itemize}
    \item If $v = \FunV(f)$ (for some $f$), then for all $d'$ such that $A ⊦ d'$, $\dom(μ) ⊦ f(d')$.
    \item If $v = \ConV(K, \many{d})$ (for some $K,\many{d}$), then $\many{A ⊦ d}$.
  \end{itemize}
  If a smallest $A$ exists such that $A ⊦ d$, $A$ is called the \emph{address domain} $\adom(d)$ of $d$.
  If a domain element $d$ has an address domain, we call it \emph{trusting}.
\end{definition}

Intuitively, a trusting domain element $d$ assumes that all the heap entries it
needs are present; it will never branch based on whether or not a heap has an
entry for a particular address.
\begin{lemma}
  For all elements $d$ and address sets $A_1 ⊆ A_2$, $A_2 ⊦ d$ implies $A_1 ⊦ d$
\end{lemma}
\begin{proof}
  $A_2$ is only used in the $\FunV$ case, where a smaller address set $A_1$ enables
\end{proof}
All the domain elements of interest to us are trusting:
\begin{lemma}
  For any expression $\pe$ and environment $ρ$ such that $\rng(ρ)$ is trusting,
  $\semevt{\pe}_ρ$ is trusting.
\end{lemma}
\begin{proof}
  By induction on $\pe$.
\end{proof}

\begin{definition}[Lazy domain]
  \label{defn:lazy-d}
  An element $d ∈ \EventD$ is \emph{lazy} if and only if
  \begin{itemize}
    \item \textup{(Well-addressed)} $d$ has a finite address domain $\adom(d)$
     \[
      \adom(d) \triangleq \bigcap \{ A \mid \forall μ.\ A ⊆ \dom(μ) \Longrightarrow d(μ) \text{ is defined} \}
     \]
     \wrt which it is \emph{well-addressed}.
    \item \textup{(Forces)} For all lazy $μ,μ' ∈ \Heaps, v ∈ \EventV$ such that
     $\bigstep{d}{μ}{v}{μ'}$, $v$ is lazy with address domain $\adom(v) ⊆ \dom(μ')$ and $μ \forcesto μ'$.
    \item \textup{(Postpone)} For all lazy $μ_1,μ_2 ∈ \Heaps$ such that $μ_1 \forcesto μ_2$ and
     $\bigstep{d}{μ_1}{v_1}{μ'_1}$ (for some $v_1,μ'_1$), we also have
     $\bigstep{d}{μ_2}{v_2}{μ'_2}$ (for some $v_2,μ'_2$) and
     $v_1 = v_2$ as well as $μ'_1 \forcesto μ'_2$.
     When $d(μ_1)$ diverges, then so does $d(μ_2)$.
    \item \textup{(Speculate)} For all lazy $μ_1,μ_2 ∈ \Heaps$ such that $μ_1 \forcesto μ_2$ and
     $\bigstep{d}{μ_2}{v_2}{μ'_2}$ (for some $v_2,μ'_2$) and $\adom(d) ⊆ \dom(μ_1)$,
     we also have $\bigstep{d}{μ_1}{v_1}{μ'_1}$ (for some $v_1,μ'_1$) and
     $v_1 = v_2$ as well as $μ'_1 \forcesto μ'_2$. When $d(μ_2)$ diverges and
     $\adom(d) ⊆ \dom(μ_1)$, then so does $d(μ_1)$.
  \end{itemize}
  A heap $μ$ \emph{lazy} if and only if every entry $d$ is lazy with domain
  $\adom(d) ⊆ \dom(μ)$. \\
  An environment $ρ$ \emph{lazy} if and only if its entries are. \\
  A value $v$ is \emph{lazy} if and only if
  \begin{itemize}
    \item It has a finite address domain $\adom(v)$ determined by the trace in which it occurs.
    \item When $v = \FunV(f)$ (for some $f$), then $f(d')$ is lazy whenever $d'$ is lazy, and $\adom(f(d')) ⊆ \adom(v) ∪ \adom(d')$.
    \item When $v = \ConV(K,\many{d})$ (for some $K,\many{d}$), then all $\many{d}$ are lazy, and $\adom(v) = \bigcup \many{\adom(d)}$.
  \end{itemize}
\end{definition}

So when an element $d$ is \emph{lazy}, every input heap forces to the output
heap, it evaluates to the same value whether or not the input heap is more or
less forced, and $\bigstep{d}{\wild}{v}{\wild}$ is natural (in the category
theoretic sense) in that it transfers the forcedness relation from input heaps
to output heaps.
Diagramatically:
\[
\begin{tikzcd}
  μ_1 \arrow[Rightarrow]{d}[swap]{\langle d, \wild\rangle}{\langle v, \wild\rangle} \arrow[rightsquigarrow]{r}{} & μ_2 \arrow[Rightarrow]{d}{\langle d, \wild\rangle}[swap]{\langle v, \wild\rangle} \\
  μ_1' \arrow[rightsquigarrow]{r}{} & μ_2'
\end{tikzcd}
\]
\noindent
Well-addressedness in conjunction with the Speculate property means that a lazy
element may branch on the contents on the heap, but not on whether or not an
entry in the heap is present.
Instead of $\pa \not∈ \adom(d)$ we will often simply say that $\pa$ is dead in $d$.

The definitions for lazy heaps, environments and values are necessary by congruence.
When we restrict ourselves to lazy heaps, we can prove transitivity of the
forcing relation.

\begin{lemma}[$(\forcesto)$ is transitive]
  \label{thm:force-heap-trans}
  Let $μ_1,μ_2,μ_3$ be lazy heaps and $μ_1 \forcesto μ_2, μ_2 \forcesto μ_3$.
  Then $μ_1 \forcesto μ_3$.
\end{lemma}
\begin{proof}
  We need a termination measure on $(\forcesto)$ before we can proceed.
  Note that in successive steps $μ_1 \forcesto ... \forcesto μ_n$ where all
  $μ_i$ are lazy heaps, heap entries progress from being undefined,
  then to a non-value denotation, and finally to a value element $\ret(v)$.

  More formally, we can define a measure $m : \Heaps \to \dom(μ_n) \pfun \{0,1,2\}$
  \[
    m(μ)(\pa) = \begin{cases}
        0 & μ(\pa) = \ret(\wild) \\
        1 & \pa ∈ \dom(μ) \\
        2 & \text{otherwise} \\
      \end{cases}
  \]
  with the pointwise partial order on $\dom(μ_n) \pfun \{0,1,2\}$.
  When $\dom(μ_n)$ is finite, this partial order has finite height, which can
  thus serve as a termination measure.

  We proceed by well-founded induction with the above measure $m$ defined on
  $\dom(μ_3)$.
  More precisely, show that the proposition is satisfied for $μ_1,μ_2,μ_3$
  assuming that the proposition holds for any $μ_1',μ_2',μ_3'$
  such that $m(μ_1') - m(μ_3') < m(μ_1) - m(μ_3)$.

  We can see that $\dom(μ_1) ⊆ \dom(μ_2) ⊆ \dom(μ_3)$, proving the first property
  of \Cref{defn:force-heap}.
  For the second property, fix an arbitrary $\pa$.
  When $μ_1(\pa) = μ_2(\pa)$ and $μ_2(\pa) = μ_3(\pa)$, we have $μ_1(\pa) = μ_3(\pa)$.
  Otherwise, either $μ_1(\pa) \not= μ_2(\pa)$ or $μ_2(\pa) \not= μ_3(\pa)$.

  Suppose that $μ_1(\pa) \not= μ_2(\pa)$.
  Then there exists $v,μ'_1$ such that $\bigstep{μ_1(\pa)}{μ_1}{v}{μ'_1}$ and
  $μ_2(\pa) = \ret(v)$ as well as $μ'_1 \forcesto μ_2$.
  By \Cref{thm:force-heap-val} applied to $μ_2 \forcesto μ_3$, we have
  $μ_2(\pa) = μ_3(\pa) = \ret(v)$.
  If $μ_1' \not= μ_1$, then $m(μ_1') < m(μ_1)$ and by well-founded induction
  we can combine $μ'_1 \forcesto μ_2$ and $μ_2 \forcesto μ_3$ to
  $μ'_1 \forcesto μ_3$.
  Hence we have shown that $μ_1 \forcesto μ_3$.

  Suppose that $μ_1(\pa) = μ_2(\pa)$, but $μ_2(\pa) \not= μ_3(\pa)$.
  Then there exists $v,μ'_2$ such that $\bigstep{μ_2(\pa)}{μ_2}{v}{μ'_2}$ and
  $μ_3(\pa) = \ret(v)$ as well as $μ'_2 \forcesto μ_3$.
  We know that $μ_1(\pa) = μ_2(\pa)$, so $\bigstep{μ_1(\pa)}{μ_2}{v}{μ'_2}$.
  Since $μ_1(\pa)$ is lazy and well-addressed \wrt $μ_1$ and $μ_1 \forcesto
  μ_2$, we get $\bigstep{μ_1(\pa)}{μ_1}{v}{μ'_1}$ such that $μ_1' \forcesto
  μ_2'$ by definition of laziness.
  By well-founded induction, we can combine $μ'_1 \forcesto μ_2'$ and
  $μ_2' \forcesto μ_3$ to $μ'_1 \forcesto μ_3$.
  If $μ_1' \not= μ_1$, then $m(μ_1') < m(μ_1)$ and by well-founded induction
  we can combine $μ'_1 \forcesto μ_2'$ and $μ_2' \forcesto μ_3$ to
  $μ'_1 \forcesto μ_3$.
  Hence have shown that $μ_1 \forcesto μ_3$.
\end{proof}

\begin{corollary}
  $(\forcesto)$ is a partial order on lazy heaps.
\end{corollary}

And now we finally prove that $\semevt{\wild}$ indeed produces a lazy element:

\begin{theorem}
  \label{thm:semevt-lazy}
  For all lazy environments $ρ$ and expressions $\pe$, $\semevt{\pe}_ρ$ is a lazy element
  with $\adom(\semevt{\pe}_ρ) ⊆ \bigcup \adom(\rng(ρ))$.
\end{theorem}
\begin{proof}
  Let us abbreviate $A \triangleq \bigcup \adom(\rng(ρ))$.
  By induction on $\pe$.
  \begin{itemize}
    \item \textbf{Case $\px$}:
      $ρ(\px)$ is lazy with address domain $\adom(ρ(\px)) ⊆ A$, and
      $\fn{\wild}{\stuckend{}}$ is stuck no matter how evaluated the heap is.

    \item \textbf{Case $\Lam{px}{\pe'}$}:
      For the Forces property, we assume a lazy $μ$ such that
      $\bigstep{\semevt{\pe}_ρ}{μ}{\FunV(f)}{μ}$ holds for
      $f \triangleq \fn{d}{\AppEA(\px↦d) \cons \semevt{\pe}_{ρ[\px↦d]}}$.
      We have $μ \forcesto μ$ by reflexivity.
      To show that $\FunV(f)$ is indeed a lazy value, we assume a lazy $d$ and
      show that $f(d)$ is lazy by induction with $\adom(f(d)) ⊆ A ∪ \adom(d)$.
      But also $A ∪ \adom(d) ⊆ \dom(μ_1) ∪ \adom(d) = \adom(\FunV(f)) ∪ \adom(d)$,
      so $\FunV(f)$ is a lazy value.
      The Well-addressed, Postpone and Speculate properties follow by assumption.

    \item \textbf{Case $K~\many{\px}$}:
      Similar to the lambda case.


    \item \textbf{Case $\pe'~\px$}:
      Both arguments to $\apply$ are lazy:
      $d \triangleq \semevt{\pe}_ρ$ is lazy by the induction hypothesis and
      $ρ(\px)$ is lazy by assumption, both with address domain in $A$.

      The interesting case is when $\bigstep{d}{μ}{\FunV(f)}{μ'}$.
      Then, $\FunV(f)$ is lazy with $\adom(\FunV(f)) ⊆ \dom(μ')$,
      and so is $f(ρ(\px))$ with $\adom(f(\px)) ⊆ \dom(μ') ∪ A = \dom(μ')$,
      so the expresson $f(ρ(\px))(μ')$ in $(\betastep)$ is well-defined.

      Hence the whole $\apply$ form is lazy and prepending the $\AppIA$ event
      does not change that because it does not affect the heap.

    \item \textbf{Case $\Case{\pe_s}{\Sel[r]}$}:
      Similar to the application case.

    \item \textbf{Case $\Let{\px}{\pe_1}{\pe_2}$}:
      Let $μ_l$ be lazy with $A ⊆ \dom(μ_l)$ and consider $\semevt{\pe}_ρ(μ_l)$.
      The key to this theorem is to prove that $\deref(\pa)$ is lazy with
      address domain $\{ \pa \}$.

      So let $μ$ be a lazy input heap that satisfies
      $\pa ∈ \dom(μ)$.
      Clearly, prepending the $\LookupA$ event in the definition of $\deref$
      does not affect the heap and thus laziness.
      The first argument to $(\betastep)$, $μ(\pa)$ requires $\pa ∈ \dom(μ)$,
      and is lazy with $\adom(μ(\pa)) ⊆ \dom(μ)$ because $μ$ is lazy, so
      $μ(\pa)(μ)$ is defined.
      Furthermore, in the interesting case $\bigstep{μ(\pa)}{μ}{v}{μ'}$
      for suitable lazy $v,μ'$, the trace resulting from calling the second
      argument to $(\betastep)$ is
      \[
        \UpdateA(\pa↦\ret(v)) \cons \goodend{v,μ'[\pa↦\ret(v)]}.
      \]
      And crucially, $μ' \forcesto μ'[\pa↦ret(v)]$ due to
      $\bigstep{μ(\pa)}{μ}{v}{μ'}$ for the differing $\pa$ entry, proving
      the Forces property.
      The Well-addressed requirement from $v$ is preserved.
      The Postpone and Speculate property for the second argument follow quite
      simply, because the updated heap entry is constant in all cases.
      We can conclude that $\deref(\pa)$ is indeed lazy with $\adom(\deref(\pa))
      = \{\pa\}$.

      Given that fact, it is easy to see that $ρ'$ in the definition
      of $\semevt{\pe}$ is lazy with address domain $A ∪ \{\pa\}$.
      Then $\semevt{\pe_i}_{ρ'}$ are lazy with address domain contained in
      $A ∪ \{\pa\}$ by induction.
      Hence $μ_l[\pa↦\semevt{\pe_1}_{ρ'}]$ is lazy, which we apply to
      $\semevt{\pe_2}_{ρ'}$, noting that the domain of the new heap
      includes $A ∪ \{\pa\}$.
      In order to show that the whole clause is lazy in $μ_l$,
      it suffices to show that $μ_l \forcesto μ_l[\pa↦\semevt{\pe_1}_{ρ'}]$
      which is simple to see because $\pa \not∈ \dom(μ_l)$.
      The Postpone and Speculate properties are unaffected.
  \end{itemize}
\end{proof}

This result justifies our tacit assumption from now on that all elements of the
semantic domain are lazy.

\subsection{A Useful Program Equivalence}

\begin{figure}
\[\begin{array}{cc}
 \begin{array}{c}
 \inferrule*[right=\eqlrcons]
    {\later (A ⊦ τ_1 \sim τ_2)}
    {A ⊦ \wild \cons τ_1 \sim \wild \cons τ_2}
 \quad
 \inferrule*[right=\eqrcons]
    {A ⊦ τ_1 \sim τ_2 \quad \fin(τ_2)}
    {A ⊦ τ_1 \sim \wild \cons τ_2}
 \quad
 \inferrule*[right=\eqlcons]
    {A ⊦ τ_1 \sim τ_2 \quad \fin(τ_1)}
    {A ⊦ \wild \cons τ_1 \sim τ_2}
 \\
 \\[-0.5em]
 \inferrule*[right=\eqstuck]
    {\quad}
    {A ⊦ \stuckend{} \sim \stuckend{}}
 \quad
 \inferrule*[right=\eqcon]
    {\later (A ⊦ \many{d_1(μ_1) \sim d_2(μ_2)})}
    {A ⊦ \goodend{\ConV(K, \many{d_1}), μ_1} \sim \goodend{\ConV(K, \many{d_2}), μ_2}}
 \\
 \\[-0.5em]
 \inferrule*[right=\textsc{Fin}]
    {τ = \many{...{}\cons {}} τ' \quad τ' \not= \wild \cons \wild}
    {\fin(τ)}
 \quad
 \inferrule*[right=\eqfun]
    {\forall d.\ \later(\adom(d) ⊆ A) ⟹  A ⊦ f_1(d)(μ_1) \sim f_2(d)(μ_2)}
    {A ⊦ \goodend{\FunV(f_1), μ_1} \sim \goodend{\FunV(f_2), μ_2}}
 \\
 \\[-0.5em]
 \inferrule*[right=\eqheap]
    {\dom(μ_1) = \dom(μ_2) \quad \forall \pa.\ \later(\dom(μ_1) ⊦ μ_1(\pa)(μ_1) \sim μ_2(\pa)(μ_2))}
    {μ_1 \approx μ_2}
 \\
 \\[-0.5em]
 \inferrule*[right=\eqdenot]
    {\forall μ_1,μ_2.\ μ_1 \approx μ_2 \wedge \adom(d_1) ∪ \adom(d_2) ⊆ \dom(μ_1) ⟹  \dom(μ_1) ⊦ d_1(μ_1) \sim d_2(μ_2)}
    {d_1 \equiv d_2}
 \end{array}
 \end{array}
\]
\caption{Semantic equivalence relation on lazy elements}
  \label{fig:sem-equiv}
\end{figure}

Consider the two expressions $\pe_1 \triangleq \Let{x}{\ttrue}{\ttrue}$ and
$\pe_2 \triangleq \Let{x}{\ffalse}{\ttrue}$.
For all intents and purposes, these two expressions are equivalent.
Indeed, they equate under $\semscott{\wild}$, suggesting that $x$ is dead
according to \Cref{defn:deadness}.

However, the definitional equality on the lazy domain $\EventD$ is \emph{too
fine}:
\[\begin{array}{rclcl}
  \semevt{\pe_1}_{[]}([])
  & = & \BindA(x,\pa_1↦\semevt{\ttrue}_{...}) \cons \goodend{\ConV(\ttrue),[\pa_1↦\semevt{\ttrue}_{...}]} \\
  & \not= & \BindA(x,\pa_1↦\semevt{\ffalse}_{...}) \cons \goodend{\ConV(\ttrue),[\pa_1↦\semevt{\ffalse}_{...}]}
  & = & \semevt{\pe_2}_{[]}([])
\end{array}\]
It would be reasonable to abstract away the contents of the trace to get a
coarser equivalence, thus eliminating the difference in $\BindA$ actions.
However, that still leaves the difference in heap entries such as $\pa_1$ which
will never be looked at!
Since the heap entry for $\pa_1$ was introduced while executing $\pe_1$/$\pe_2$,
we will call them \emph{local} to the trace $\semevt{\pe_i}_{[]}([])$.
It is prudent for the observer to ignore local entries.

That is the essence of what the \emph{semantic equivalence relation} $(\equiv)$
defined on lazy elements in \Cref{fig:sem-equiv} does.
It is coarse enough to equate the example above, but still finer than contextual
equivalence, as we shall see.

The key is its observer model for function values, which necessitates the
address space parameter $A$ in the bisimulation $\sim$ to track non-local
addresses.
Consider a successful evaluation $\bigstep{d_i}{μ_i}{\FunV(f_i)}{μ_i'}$, as in
\[\begin{array}{rclcl}
  \semevt{\Let{y}{x}{\Lam{z}{y}}}_{[x↦d]}([])
  & = & ... \cons \goodend{\FunV(\fn{\wild}{\deref(\pa_1)}),[\pa_1↦d]} \\
  & \equiv & ... \cons \goodend{\FunV(\fn{\wild}{d}),[]} \\
  & = & \semevt{\Lam{z}{x}}_{[x↦d]}([])
\end{array}\]
where
\[
  μ_1 = μ_2 = μ_2' = [], μ_1' = [\pa_1↦d], f_1 = \fn{\wild}{\deref(\pa_1)}, f_2 = \fn{\wild}{d}.
\]
The denotations of the two expressions are not definitionally equivalent in the final heap,
yet they are semantically equivalent.
To see that, we have to relate $\deref(\pa_1)$ to $d$, which only succeeds if
the former has access to the local entries in $μ_1'$.
So if $\wild ⊦ \wild \sim \wild$ were to discard final heaps completely and
compare values on the initial empty heap, that would be impossible.

On the other hand, the observer may probe functions for equality by supplying
(nearly) any argument denotation they wish.
The following example illustrates how exactly such argument denotations should be
restricted:
\[\begin{array}{rclcl}
  \semevt{\Let{x}{\ttrue}{\Lam{y}{y}}}_{[]}([])
  & = & ... \cons \goodend{\FunV(\fn{d}{d}),[\pa_1↦\semevt{\ttrue}_{...}]} \\
  & \equiv & ... \cons \goodend{\FunV(\fn{d}{d}),[]} \\
  & = & \semevt{\Lam{y}{y}}_{[]}([]),
\end{array}\]
In both cases, the function value $\FunV(\fn{d}{d})$ is to be probed by the
observer with an argument $d'$.
If the observer was given free reign, they would certainly be able to tell apart
$d'([])$ from $d'([\pa_1↦\semevt{\ttrue}_{...}])$, for example by branching
in $d'(μ)$ based on $\pa_1 ∈ \dom(μ)$.
Since the parameter $A$ tracks non-local addresses (as can be asserted in
$\equiv$), we can prohibit such exploits by requiring that $\adom(d') ⊆ A$.

\begin{lemma}[Weakening of address domain]
  \label{thm:weaken-address-domain}
  For all address domains $A_1 ⊆ A_2$ and traces $τ_1,τ_2$, if $A_2 ⊦ τ_1 \sim τ_2$ then $A_1 ⊦ τ_1 \sim τ_2$.
\end{lemma}
\begin{proof}
  Take note that the check $\adom(d) ⊆ A$ occurs in negative
  position in $\wild ⊦ \wild \sim \wild$ and $A$ is never used anywhere else.
  Intuitively, the smaller $A$, the fewer $d$s the caller is allowed to
  ``probe'' $\FunV$ values with and the easier it is to prove bisimilarity.
\end{proof}

Evaluating lazy elements on heaps that force to each other is semantically equivalent:

\begin{lemma}
  \label{thm:lazy-force-bisimilar}
  Let $d$ be lazy. Then for all $μ_1,μ_2$ with $\adom(d) ⊆ \dom(μ_1)$ and
  $μ_1 \forcesto μ_2$, we have $\dom(μ_1) ⊦ d(μ_1) \sim d(μ_2)$.
\end{lemma}
\begin{proof}
  This lemma makes essential use of the Postpone and Speculate properties.
  Note that we are free to make use of the latter because $d$ is well-addressed
  at $μ_1$.

  If either $d(μ_1)$ or $d(μ_2)$ diverges, then so does the other, in which case
  $\dom(μ_1) ⊦ d(μ_1) \sim d(μ_2)$.
  If either $\bigstep{d}{μ_1}{v}{μ_1'}$ or $\bigstep{d}{μ_2}{v}{μ_2'}$ then both
  judgments hold and $μ_1' \forcesto μ_2'$, so it suffices to show
  ${\dom(μ_1) ⊦ \goodend{v}{μ_1'} \sim \goodend{v}{μ_2'}}$.

  For the $\ConV$ case, we can show $\later(\many{\dom(μ_1) ⊦ d(μ_1') \sim d(μ_2')})$
  via Löb induction, because $μ_1' \forcesto μ_2'$ and we may relax the address
  space from $\dom(μ_1')$ to $\dom(μ_1)$ via \Cref{thm:weaken-address-domain}.

  For the $\FunV(f)$ case, we assume that $\adom(d) ⊆ \dom(μ_1)$ holds for some
  $d$ and have to show that $\dom(μ_1) ⊦ f(d)(μ_1') \sim f(d)(μ_2')$.
  Again, that follows via Löb induction, because $μ_1' \forcesto μ_2'$ and we
  may relax the address space from $\dom(μ_1')$ to $\dom(μ_1)$ via
  \Cref{thm:weaken-address-domain}.

  If either $d(μ_1)$ or $d(μ_2)$ is ultimately stuck, then so is the other,
  because it neither diverges nor evaluates.
  In that case, we see that $\dom(μ_1) ⊦ d(μ_1) \sim d(μ_2)$.
\end{proof}

\begin{theorem}
  For any $A$, $A ⊦ \wild \sim \wild$ is an equivalence relation on lazy traces.
\end{theorem}
\begin{proof}
Reflexivity follows by straightforwardly by Löb induction.
Symmetry does so as well, with the twist that the rule applications of
$\eqlcons$ and $\eqrcons$ need to be swapped.

For transitivity, it is worth reviewing a few cases, so assume
$A ⊦ τ_1 \sim τ_2$, $A ⊦ τ_2 \sim τ_3$ to show $A ⊦ τ_1 \sim τ_3$ by Löb
induction, \eg, assuming that
\[
  \later(A ⊦ τ_1 \sim τ_2 \wedge A ⊦ τ_2 \sim τ_3 \Longrightarrow A ⊦ τ_1 \sim τ_3)
\]
for all $τ_1,τ_2,τ_3$.

By cases on the last rule applied to either $A ⊦ τ_1 \sim τ_2$ or $A ⊦ τ_2 \sim τ_3$.
\begin{itemize}
  \item \textbf{Case }$\eqlcons$ to $A ⊦ τ_1 \sim τ_2$:
    Then $τ_1 = \wild \cons τ_1'$ and $A ⊦ τ_1' \sim τ_2$.
    We can apply the induction hypothesis to get $A ⊦ τ_1' \sim τ_3$
    and re-apply $\eqlcons$.
  \item \textbf{Case }$\eqrcons$ to $A ⊦ τ_2 \sim τ_3$: Similar.
  \item \textbf{Case }$\eqrcons$ to $A ⊦ τ_1 \sim τ_2$:
    Then $τ_2 = \wild \cons τ_2'$, $\fin(τ_2')$ and $A ⊦ τ_1 \sim τ_2'$.
    $\fin(τ_2')$ means that the entire derivation is of finite height.
    By rule inversion on $A ⊦ τ_2 \sim τ_3$, either $\eqlcons$ or $\eqlrcons$
    applies.
    If we unpack $\eqlcons$, then $A ⊦ τ_2' \sim τ_3$ and we can apply the
    induction hypothesis to get $A ⊦ τ_1 \sim τ_3$.
    Otherwise we unpack $\eqlrcons$ and get $A ⊦ τ_2' \sim τ_3'$ for
    some $τ_3'$ to which we apply the induction hypothesis to get
    $A ⊦ τ_1 \sim τ_3'$ which we wrap up with $\eqrcons$.
  \item \textbf{Case }$\eqlrcons$ to $A ⊦ τ_1 \sim τ_2$: Similar.
  \item \textbf{Case }$\eqfun$ to $A ⊦ τ_1 \sim τ_2$:
    By rule inversion on $A ⊦ τ_2 \sim τ_3$, $\eqfun$ must apply.
    The rest is a simple matter of applying the inductive hypothesis.
  \item \textbf{Case }$\eqcon$ to $A ⊦ τ_1 \sim τ_2$: Similar.
  \item \textbf{Case }$\eqstuck$ to $A ⊦ τ_1 \sim τ_2$: Similar.
\end{itemize}
\end{proof}

It follows that $\approx$ is an equivalence relation on lazy heaps.

Unfortunately, the notion of a lazy element we have is too weak to prove
reflexivity of $(\equiv)$.
We fix that by introducing the following extensionality requirement on lazy
elements $d$:

\begin{definition}[Extensionality]
  A lazy element $d$ is \emph{extensional} if and only if $d \equiv d$.
\end{definition}

\begin{theorem}
  $(\equiv)$ is an equivalence relation on lazy and extensional elements in
  $\EventD$.
\end{theorem}
\begin{proof}
Reflexivity follows by extensionality.
Symmetry follows straightforwardly by Löb induction, noting that the $\dom(μ_1)$
requirement in $(\equiv)$ can be replaced with $\dom(μ_2)$ due to the
$μ_1 \approx μ_2$ premise.

Now we show transitivity.
First note that for any $μ_1 \approx μ_3$, we can find $μ_2$ such that $μ_1
\approx μ_2 \approx μ_3$, simply by permuting one entry

Assume that $d_1 \equiv d_2$ and $d_2 \equiv d_3$.
We have to show that $d_1 \equiv d_3$.

For that we assume $μ_1 \approx μ_3$ for some $μ_1,μ_3$ such that
$\adom(d_1) ∪ \adom(d_3) ⊆ \dom(μ_1)$ and have to show that
\[
  \dom(μ_1) ⊦ d_1(μ_1) \sim d_3(μ_3).
\]
We can construct extended heaps $μ_1' \approx μ_3'$ such that
$μ_1 \forcesto μ_1'$, $μ_3 \forcesto μ_3'$ and $\adom(d_2) ⊆ \dom(μ_i')$.

Clearly, $μ_1' \approx μ_1'$ by reflexivity, so we can invoke $d_1 \equiv d_2$
to get
\[
  \dom(μ_1') ⊦ d_1(μ_1') \sim d_2(μ_1').
\]
We invoke $d_2 \equiv d_3$ on $μ_1' \approx μ_3'$ to get
\[
  \dom(μ_1') ⊦ d_2(μ_1') \sim d_3(μ_3')
\]
and by transitivity we get
\[
  \dom(μ_1') ⊦ d_1(μ_1') \sim d_3(μ_3')
\]
which can be weakened via \Cref{thm:weaken-address-domain} to $\dom(μ_1)$.
\end{proof}

Note that we only make use of extensionality to prove reflexivity; in fact,
$(\equiv)$ is still a partial equivalence relation on lazy elements.

What remains is a proof that $\semevt{\pe}_ρ$ is indeed extensional for
extensional $ρ$.

\begin{theorem}
  For all extensional environments $ρ$ and expressions $\pe$,
  $\semevt{\pe}_ρ$ is extensional.
\end{theorem}
\begin{proof}
By induction on $\pe$.
\begin{itemize}
  \item \textbf{Case $\px$}:
    By assumption, $ρ(\px)$ is extensional.

  \item \textbf{Case $\Lam{\px}{pe'}$}:
    Fix a particular $μ_1 \approx μ_2$. The goal is to show
    \[
      \dom(μ_1) ⊦ \goodend{v,μ_1} \sim \goodend{v,μ_2}
    \]
    where $v \triangleq \FunV(\fn{d^\later}{\AppEA(\px↦d^\later) \cons \semevt{\pe}_{ρ[\px↦d^\later]}})$.
    So let us fix (extensional!) $d$ such that $\adom(d) ⊆ \dom(μ_1)$ and show
    \[
      \dom(μ_1) ⊦ \semevt{\pe}_{ρ[\px↦d]}(μ_1) \sim \semevt{\pe}_{ρ[\px↦d]}(μ_2)
    \]
    which follows by the extensionality of $\semevt{\pe}_{ρ[\px↦d]}$.

  \item \textbf{Case $K~\many{\px}$}:
    Similar to the lambda case.

  \item \textbf{Case $\pe'~\px$}:
    $\fn{\wild}{\stuckend{}}$ is extensional in case $\px \not∈ \dom(ρ)$.

    Otherwise, by induction it suffices to show that for extensional
    $d \triangleq \semevt{\pe'}_ρ$, $d \betastep \fn{(\FunV(f))}{f(ρ(\px))}$
    is extensional.

    Now fix particular $μ_1 \approx μ_2$ such that $A ⊆ \dom(μ_1)$.
    The interesting case is when $\bigstep{d}{μ_i}{\FunV(f_i)}{μ'_i}$.
    We have to show that $\dom(μ_1) ⊦ f_1(ρ(\px))(μ_1') \sim f_2(ρ(\px))(μ_2')$,
    the rest follows by congruence.
    From extensionality of $d$, we know by $\eqfun$ that
    $\dom(μ_1) ⊦ f_1(d')(μ_1') \sim f_2(d')(μ_2')$ for any $d'$ such that
    $\adom(d') ⊆ \dom(μ_1)$.
    Since $\adom(ρ(\px)) ⊆ \dom(μ_1)$, we can show the goal.

  \item \textbf{Case $\Case{\pe_s}{\Sel[r]}$}:
    Similar to the application case.

  \item \textbf{Case $\Let{\px}{\pe_1}{\pe_2}$}:
    We first show that $\deref(\pa)$ is extensional.
    Let $μ_1 \approx μ_2$ such that $\pa ∈ \dom(μ_i)$ and abbreviate
    $d_i \triangleq μ_i(\pa)$.
    Then the goal is to show that
    \[
      \dom(μ_1) ⊦ (d_1 \betastep f)(μ_1) \sim (d_2 \betastep f)(μ_2)
    \]
    where $f \triangleq  \fn{v\,μ'}{\UpdateA(\pa↦\ret(v)) \cons \goodend{v,μ'[\pa↦\ret(v)]}}$.

    The interesting case is when $\bigstep{d_i}{μ_i}{v}{μ'_i}$, otherwise
    $\dom(μ_1) ⊦ d_1(μ_1) \sim d_2(μ_2)$ per assumption of $μ_1 \approx μ_2$.
    We have to show that
    \[\begin{array}{l}
       \dom(μ_1) ⊦ \goodend{v_1,μ_1'} \sim \goodend{v_2,μ_2'} \\
       \Longrightarrow \\
       \dom(μ_1) ⊦ \goodend{v_1,μ_1'[\pa↦\ret(v_1)]} \sim \goodend{v_2,μ_2'[\pa↦\ret(v_2)]}
    \end{array}\]
    But since $μ_i' \forcesto μ_i'[\pa↦\ret(v_i)]$, we can apply
    \Cref{thm:lazy-force-bisimilar} twice and transitivity of $\sim$ to show the
    goal.

    For extensionality of $\semevt{\Let{\px}{\pe_1}{\pe_2}}_ρ$, note
    that the equivalence $μ_1 \approx μ_2$ can be extended to
    $μ_1[\pa ↦ d] \approx μ_2[\pa ↦ d]$ for any $d$ by reflexivity of
    $\sim$.
    With extensionality of $\deref(\pa)$ for $\pa ∈ \dom(μ_i)$ and abbreviating
    $ρ' \triangleq ρ[\px↦\deref(\pa)]$ the above holds for
    $d \triangleq \semevt{\pe_1}_ρ'$ in particular.
    Then the goal follows by the inductive hypothesis applied to
    extensionality of $\semevt{\pe_2}_{ρ'}$ and
    \Cref{thm:weaken-address-domain}.
\end{itemize}
\end{proof}

The proof needs to assume that all probing $d$s in $\eqfun$ are extensional, so
the equivalence relation on lazy and extensional elements is not necessarily a
subrelation of the partial equivalence relation on lazy elements.

As before, we will assume that all elements $d$ are lazy and extensional from
now on.

\subsection{Compositionality}

It is simple to prove that $\semevt{\wild}$ is \emph{compositional}
\wrt definitional equality $=$ on $\EventD$:
For any $\pe_1,\pe_2$ and $ρ$, if $\semevt{\pe_1}_ρ = \semevt{\pe_2}_ρ$
then $\semevt{C[\pe_1]}_ρ = \semevt{C[\pe_2]}_ρ$ for any \emph{context} $C$.
(We will define $C$ precisely in a minute.)
The proof is immediate because of structural recursion and extensionality of
functions.

%Since $\semevt{C[\pe_1]}_ρ = \semevt{C[\pe_2]}_ρ$ implies that $C[\pe_i]$ have
%the same termination behavior via adequacy, compositionality also implies
%contextual equivalence.
%Thus, definitional equality and $\semevt{\wild}$ induce an equivalence relation
%on terms that is \emph{finer} than contextual equivalence.

More interestingly, $\semevt{\wild}$ is also compositional \wrt to $(\equiv)$!

As compositionality is a property referring to contexts (called $C$ above), we
need syntax for \emph{evaluation contexts} $\pE$%
\footnote{In \Cref{defn:deadness2} we already used the term ``evaluation
context'' to denote small-step machine components $(ρ,μ,κ)$ rather than to
$\pE$. \citet{MoranSands:99} prove that both notions are equivalent, so this
overload is justified.}
with holes $\hole$ in order to formalise compositionality.
Then $\pE[\pe]$ denotes an expression where the hole in $\pE$ has been replaced
with $\pe$.
\[\begin{array}{rcl}
  \pE & ::=  & \hole \mid \pE~\px \mid \Let{\px}{\pe}{\pE} \mid \Let{\px}{\pE}{\pE[\px]} \mid \Case{\pE}{\Sel[r]} \\
\end{array}\]

\begin{definition}[Compositionality of an equivalence relation]
  Let $\cong$ be an equivalence relation on expressions.
  $\cong$ is \emph{compositional} if and only if for all $\pe_1,\pe_2$
  $\pe_1 \cong \pe_2$ implies $\pE[\pe_1] \cong \pE[\pe_2]$ for all evaluation
  contexts $\pE$.
\end{definition}

It is well-known that \emph{contextual equivalence} is compositional:

\begin{definition}[Contextual equivalence, as in \citep{MoranSands:99}]
  Two expressions $\pe_1,\pe_2$ are \emph{contextually equivalent}, written
  $\pe_1 \equiv_{\mathit{ctx}} \pe_2$, if their termination behavior conincides
  in all contexts, \eg, for all closed evaluation contexts $\pE$ it is
  \[
    \len(\semevt{\pE[\pe_1]}_{[]}([])) = ω \Longleftrightarrow \len(\semevt{\pE[\pe_2]}_{[]}([])) = ω
  \]
  where $\len$ is the length function from \Cref{defn:length}.
\end{definition}

The definition of \citet{MoranSands:99} is in terms of a transition system like
$(\smallstep)$, but adequacy (\Cref{thm:semst-adequate}) guarantees that the two
notions coincide.

\begin{lemma}[Contextual equivalence is compositional]
  Let $\pe_1, \pe_2$ be expressions such that
  $\pe_1 \equiv_{\mathit{ctx}} \pe_2$.
  Then for all evaluation contexts $\pE$, we have
  $\pE[\pe_1] \equiv_{\mathit{ctx}} \pE[\pe_2]$.
\end{lemma}
\begin{proof}
  Immediate, because $\pE[\pE_2[\hole]]$ is just another context in which
  contextually equivalent expressions are contextually equivalent.
\end{proof}

In a slight overloading of terms, we associate with ``semantic equivalence''
the relation
$\fn{\pe_1~\pe_2}{\forall ρ.\ \semevt{\pe_1}_ρ \equiv \semevt{\pe_2}_ρ}$ and
go on to prove compositionality:

\begin{theorem}[Semantic equivalence is compositional]
  Let $\pe_1, \pe_2$ be expressions such that
  for all environments $ρ$, $\semevt{\pe_1}_ρ \equiv \semevt{\pe_2}_ρ$.
  Then for all evaluation contexts $\pE$ and environments $ρ$, we have
  $\semevt{\pE[\pe_1]}_{ρ} \equiv \semevt{\pE[\pe_2]}_{ρ}$.
\end{theorem}
\begin{proof}
  By induction on $\pE$, considering a particular $ρ$ and taking $A = \adom(\rng(ρ))$.
  \begin{itemize}
    \item \textbf{Case $\hole$}: By assumption, $\semevt{\pe_1}_ρ \equiv \semevt{\pe_2}_ρ$.

    \item \textbf{Case $\pE~\px$}:
      It is $\fn{\wild}{\stuckend{}} \equiv \fn{\wild}{\stuckend{}}$ in case $\px \not∈ \dom(ρ)$.

      Otherwise, by Löb induction it suffices to show that for $d_1 \equiv d_2$, we have
      \[
        d_1 \betastep \fn{(\FunV(f))}{f(ρ(\px))} \equiv d_2 \betastep \fn{(\FunV(f))}{f(ρ(\px))}.
      \]
      Now fix particular $μ_1 \approx μ_2$ such that $A ⊆ \dom(μ_1)$.
      The interesting case is when $\bigstep{d_1}{μ_1}{\FunV(f_1)}{μ'_1}$.
      We have to show that $A ⊦ f_1(ρ(\px))(μ_1) \sim f_2(ρ(\px))(μ_2)$, the
      rest follows by congruence.
      From $d_1 \equiv d_2$, we know that $\dom(μ_1) ⊦ f_1(d)(μ_1) \sim f_2(d)(μ_2)$ for any lazy $d$ such that $\adom(d) ⊆ \dom(μ_1)$.
      By \Cref{thm:weaken-address-domain}, we can weaken $\dom(μ_1)$ to $A$.
      Since $\adom(ρ(\px)) ⊆ \dom(μ_1)$ we can show the goal.

    \item \textbf{Case $\Case{\pE}{\Sel[r]}$}:
      Similar to the application case.

    \item \textbf{Case $\Let{\px}{\pe}{\pE}$}:
      Note that the equivalence $μ_1 \approx μ_2$ can be extended to
      $μ_1[\pa ↦ d] \approx μ_2[\pa ↦ d]$ for any $d$ by reflexivity of
      $\equiv$, and for $d \triangleq \semevt{\pe}_ρ'$ in particular.
      Then the goal follows by the inductive hypothesis applied to
      $\semevt{\pE[\pe_1]}_{ρ'} \equiv \semevt{\pE[\pe_2]}_{ρ'}$ on address
      domain $A ∪ \{ \pa \}$ and \Cref{thm:weaken-address-domain}.

    \item \textbf{Case $\Let{\px}{\pE_1}{\pE_2[\px]}$}:
      Fix a particular $μ_1 \approx μ_2$.
      The induction hypothesis gives us
      $\semevt{\pE_1[\pe_1]}_{ρ'} \equiv \semevt{\pE_1[\pe_2]}_{ρ'}$,
      so $μ_1[\pa ↦ \semevt{\pE_1[\pe_1]}_{ρ'}] \approx μ_2[\pa ↦ \semevt{\pE_1[\pe_2]}_{ρ'}]$
      and we get
      \[
        A ∪ \{ \pa \} ⊦ \semevt{\pE_2[\px]}_{ρ'}(μ_1[\pa ↦ \semevt{\pE_1[\pe_1]}_{ρ'}]) \sim \semevt{\pE_2[\px]}_{ρ'}(μ_2[\pa ↦ \semevt{\pE_1[\pe_2]}_{ρ'}])
      \]
      by Löb induction on $\pE_2[\px]$ and definition of semantic equivalence.
  \end{itemize}
\end{proof}

And finally, we can prove that $(\equiv)$ is indeed coarser than contextual equivalence:

\begin{corollary}[Semantic equivalence implies contextual equivalence]
  Let $\pe_1, \pe_2$ be expressions such that $\semevt{\pe_1}_ρ \equiv \semevt{\pe_2}_ρ$.
  Then for all closed evaluation contexts $\pE$, we have
  \[
    \len(\semevt{\pE[\pe_1]}_{[]}([])) = ω \Leftrightarrow \len(\semevt{\pE[\pe_1]}_{[]}([])) = ω.
  \]
\end{corollary}
\begin{proof}
  It suffices to show that for all $d_1,d_2$ with $\adom(d_1) = \adom(d_2) = \varnothing$,
  if $d_1 \equiv d_2$ then $\len(d_1([])) = ω \Leftrightarrow \len(d_2([])) = ω$.

  Since $[] \approx []$, we have $\varnothing ⊦ d_1([]) \sim d_2([])$.
  Then if either trace diverges, so does the other, in which case their length is $ω$.
\end{proof}

This corollary natural leads to the converse question:
Does contextual equivalence imply semantic equivalence?
If that were the case, then $\semevt{\wild}$ would be \emph{fully abstract} via
$(equiv)$~\citep{Plotkin:77}.
\citeauthor{Plotkin:77} established that $\semscott{\wild}$ was not fully
abstract via definitional equality on $\ScottD$.
Guarded types prevent probing for diverging computations without executing them,
but it is still possible for lazy elements to probe traces for stuckness, so we
have reason to doubt that $\semevt{\wild}$ is fully abstract.
We do not intend to find a final answer in this work.
