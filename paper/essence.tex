\section{The Imperative Essence of Memoisation}
\label{sec:essence}

Before we can talk about abstraction, we have to record a few meta-theoretic
properties.
We will prove these properties in terms of the eventful semantics
$\semevt{\wild}$ but they apply to the $\semvan{\wild}$ as well.

\subsection{Heap Forcing and Laziness}

As we have observed in \Cref{sec:problem}, the semantics of call-by-need is more
complicated than the semantics for call-by-name and call-by-value because it
relies on a heap to implement thunk memoisation.
This leads to a tricky domain model that passes around
heaps as state and exposes tiresome operational detail such as heap addresses.

On the other hand, memoisation is a very ``benign'' use of state and often we
can reason rather naturally about call-by-need programs without thinking too
much about heaps, in contrast to a call-by-name calculus with arbitrary
assignments to ref cells.

For example, we can observe that heaps in our semantics evolve in a very
specific way:
When $\semevt{\pe}_ρ(μ) = ... \cons \goodend{v,μ'}$, we intuit that $μ'$ must be
``at least as evaluated'' as $μ$, \eg, for all $\pa ∈ \dom(μ)$ either $μ(\pa) =
μ'(\pa)$ or $μ'(\pa)$ is ``the value of'' $μ(\pa)$.
We make this observation precise via the following definitions:

\begin{definition}[Big-step]
  \label{defn:eval-d}
  For all $d ∈ \EventD$, $v ∈ \EventV$, $μ, μ' ∈ \Heaps$ we say that
  $d$ \emph{evaluates} in $μ$ to $(v,μ')$ (written $\bigstep{d}{μ}{v}{μ'}$) if
  and only if $d(μ) = ... \cons \goodend{v,μ'}$.
\end{definition}

Big-step notation deliberately throws away much information about the trace,
retaining only whether it was balanced and what the final value and heap is,
hence the name ``big-step'' is fitting.

\begin{definition}[Heap forcing]
  \label{defn:force-heap}
  For all $μ_1, μ_2 ∈ \Heaps$, $μ_1$ \emph{forces} to $μ_2$
  (written $μ_1 \forcesto μ_2$) if and only if,
  \begin{enumerate}
    \item $\dom(μ_1) ⊆ \dom(μ_2)$, and
    \item For all $\pa ∈ \dom(μ_1)$, either
      \begin{itemize}
        \item $μ_1(\pa) = μ_2(\pa)$, or
        \item there exists $v,μ'_1$ such that
          $\bigstep{μ_1(\pa)}{μ_1}{v}{μ'_1}$, $μ_2(\pa) = \memo(\pa,\ret(v))$
          and $μ'_1 \forcesto μ_2$.
      \end{itemize}
  \end{enumerate}
\end{definition}

(We understand \Cref{defn:force-heap} inductively, so $(\forcesto)$ is the least
fixpoint of the implied functional.)

Our earlier intuition can now be formulated as follows:
If $\bigstep{\semevt{\pe}_ρ}{μ}{v}{μ'}$, then $μ \forcesto μ'$.

Just as lambda terms are often identified modulo consistent renaming
(α-equivalence), we have so far treated LK machine states $σ$ equivalent modulo
consistent \emph{readdressing}, \ie, consistent substitution of all address
values.
Likewise, for the remainder of this work, we will identify trace-based
\emph{heaps} modulo consistent readdressing.
Of course, a rigorous treatment would have to carry around readdressing
substitutions and apply them to adjust the domain of a heap, its entries,
as well as the heaps, domain elements and values in the returned traces.

Once a heap entry is evaluated, it stays that way during forcing:

\begin{lemmarep}
  \label{thm:force-heap-val}
  For all $μ_1,μ_2,\pa,v$ such that $μ_1 \forcesto μ_2$ and $μ_1(\pa) = \memo(\pa,\ret(v))$,
  then $μ_2(\pa) = \memo(\pa,\ret(v))$.
\end{lemmarep}
\begin{proof}
  Immediate proof by contraposition and unfolding of $\ret$.
\end{proof}

The heap forcing relation is reflexive (it is always $μ(\pa) = μ(\pa)$) and
also antisymmetric:

\begin{lemmarep}[$(\forcesto)$ is antisymmetric]
  \label{thm:force-heap-trans}
  Let $μ_1,μ_2$ be heaps and $μ_1 \forcesto μ_2, μ_2 \forcesto μ_1$.
  Then $μ_1 = μ_2$.
\end{lemmarep}
\begin{proof}
  It is easy to see that both $μ_1$ and $μ_2$ must have the same domain.

  Now suppose that there exists $\pa$ such that $μ_1(\pa) \not= μ_2(\pa)$.
  Then there exists $v_1$ such that $\bigstep{μ_1(\pa)}{μ_1}{v_1}{\wild}$ and
  $μ_2(\pa) = \memo(\pa, \ret(v_1))$.
  By \Cref{thm:force-heap-val} applied to $μ_2 \forcesto μ_1$, we get $μ_1(\pa)
  = \memo(\pa, \ret(v_1)) = μ_2(\pa)$, a contradiction.
\end{proof}

(It is worth stressing that antisymmetry only holds on equivalence classes modulo readdressing.)
However, $(\forcesto)$ is not easily proven transitive without further
characterisation of the domain elements returned by $\semevt{\wild}$.

\begin{definition}[Lazy domain]
  \label{defn:lazy-d}
  An element $d ∈ \EventD$ is \emph{lazy} if and only if
  \begin{itemize}
    \item \textup{(Address Domain)} There is a smallest set $A ⊆ \Addresses$ for
      which $d(μ)$ is defined whenever $A ⊆ \dom(μ)$; otherwise $d(μ)$ is
      undefined. We write $\adom(d)$ when referring to this set.%
      \footnote{In our Agda formalisation, the address domain is a parameter of
      $\EventD$, and heaps are total functions from $A$ to $\EventD(A)$.}
    \item \textup{(Forces)} For all lazy $μ,μ' ∈ \Heaps, v ∈ \EventV$ such that
     $\bigstep{d}{μ}{v}{μ'}$, $v$ is lazy and $μ \forcesto μ'$.
    \item \textup{(Postpone)} For all lazy $μ_1,μ_2 ∈ \Heaps$ such that $μ_1 \forcesto μ_2$,
     \begin{itemize}
       \item If $\bigstep{d}{μ_1}{v_1}{μ'_1}$ (for some $v_1,μ'_1$) then
         $\bigstep{d}{μ_2}{v_2}{μ'_2}$ (for some $v_2,μ'_2$) and
         $v_1 = v_2$ as well as $μ'_1 \forcesto μ'_2$
       \item If $d(μ_1)$ diverges then so does $d(μ_2)$.
     \end{itemize}
    \item \textup{(Speculate)} For all lazy $μ_1,μ_2 ∈ \Heaps$ such that $μ_1 \forcesto μ_2$ and $d(μ_1)$ is defined,
     \begin{itemize}
       \item If $\bigstep{d}{μ_2}{v_2}{μ'_2}$ (for some $v_2,μ'_2$) then
         $\bigstep{d}{μ_1}{v_1}{μ'_1}$ (for some $v_1,μ'_1$) and
         $v_1 = v_2$ as well as $μ'_1 \forcesto μ'_2$
       \item If $d(μ_2)$ diverges then so does $d(μ_1)$.
     \end{itemize}
  \end{itemize}
  A heap $μ$ is \emph{lazy} if and only if it is of the form $[\many{\pa↦\memo(\pa,d)}]$ and all $\many{d}$ are lazy and defined on $μ$.\\
  A value $v$ is \emph{lazy} if and only if $v = \FunV(f)$ (for some $f$) implies that $f(\pa)$ is lazy.
\end{definition}

So when an element $d$ is \emph{lazy}, every input heap forces to the output
heap, it evaluates to the same value whether or not the input heap is more or
less forced, and $\bigstep{d}{\wild}{v}{\wild}$ is natural (in the category
theoretic sense) in that it transfers the forcedness relation from input heaps
to output heaps.
Diagramatically:
\vspace{-\baselineskip}
\[
\begin{tikzcd}
  μ_1 \arrow[Rightarrow]{d}[swap]{\langle d, \wild\rangle}{\langle v, \wild\rangle} \arrow[rightsquigarrow]{r}{} & μ_2 \arrow[Rightarrow]{d}{\langle v, \wild\rangle}[swap]{\langle d, \wild\rangle} \\
  μ_1' \arrow[rightsquigarrow]{r}{} & μ_2'
\end{tikzcd}
\]
\noindent
The Address Domain property in conjunction with the Speculate property means
that a lazy element may branch on the contents of the heap, but not on whether
or not an entry in the heap is present.

The definitions for lazy heaps, environments and values are necessary by congruence.
When we restrict ourselves to lazy heaps, we can prove transitivity of the
forcing relation.

\begin{lemmarep}[$(\forcesto)$ is transitive]
  \label{thm:force-heap-trans}
  Let $μ_1,μ_2,μ_3$ be lazy heaps and $μ_1 \forcesto μ_2, μ_2 \forcesto μ_3$.
  Then $μ_1 \forcesto μ_3$.
\end{lemmarep}
\begin{proof}
  We need a termination measure on $(\forcesto)$ before we can proceed.
  Note that in successive steps $μ_1 \forcesto ... \forcesto μ_n$ where all
  $μ_i$ are lazy heaps, heap entries progress from being undefined,
  then to a non-value denotation, and finally to a value element $\memo(\pa, \ret(v))$.

  More formally, we can define a measure $m : \Heaps \to \dom(μ_n) \to \{0,1,2\}$
  \[
    m(μ)(\pa) = \begin{cases}
        0 & μ(\pa) = \memo(\pa, \ret(\wild)) \\
        1 & \pa ∈ \dom(μ) \\
        2 & \text{otherwise} \\
      \end{cases}
  \]
  with the pointwise partial order on $\dom(μ_n) \to \{0,1,2\}$.
  When $\dom(μ_n)$ is finite, this partial order has finite height, which can
  thus serve as a termination measure.
  Note that $μ_1 \forcesto μ_2$ and $μ_1 \not= μ_2$  implies (1) $m(μ') < m(μ)$     % Obs1
  as well as that (2) there exists $μ_1' \not= μ_1$ such that $μ_1' \forcesto μ_2$. % Obs2
  Both facts follow by induction on $μ_1 \forcesto μ_2$.

  We proceed by well-founded induction with the above measure $m$ defined on
  $\dom(μ_3)$.
  More precisely, we show that the proposition is true for $μ_1,μ_2,μ_3$
  assuming that the proposition holds for any $μ_1',μ_2',μ_3'$
  such that $m(μ_1') - m(μ_3') < m(μ_1) - m(μ_3)$.

  We can see that $\dom(μ_1) ⊆ \dom(μ_2) ⊆ \dom(μ_3)$, proving the first property
  of \Cref{defn:force-heap}.
  For the second property, fix an arbitrary $\pa$.

  \begin{itemize}
    \item \textbf{Case $μ_1(\pa) = μ_2(\pa) = μ_3(\pa)$}:
      Then we have $μ_1(\pa) = μ_3(\pa)$, so we apply (1) of \Cref{defn:force-heap}.
    \item \textbf{Case $μ_1(\pa) \not= μ_2(\pa)$}:
      Then there exists $v,μ'_1$ such that $\bigstep{μ_1(\pa)}{μ_1}{v}{μ'_1}$ and
      $μ_2(\pa) = \memo(\pa,\ret(v))$ as well as $μ'_1 \forcesto μ_2$.

      Since $μ_1 \not= μ_2$, some step in the chain
      $μ_1 \forcesto μ_1' \forcesto μ_2$ must be proper.
      Without loss of generality, we assume $μ_1 \not= μ_1'$;
      otherwise $μ_1' \forcesto μ_2$ must be proper and we apply observation (2).

      It follows that $m(μ_1') < m(μ_1)$ because $μ_1 \forcesto μ_1'$ by
      the Forces property of laziness, and by well-founded induction we can combine
      $μ'_1 \forcesto μ_2$ and $μ_2 \forcesto μ_3$ to $μ'_1 \forcesto μ_3$.
      By \Cref{thm:force-heap-val} applied to $μ_2 \forcesto μ_3$, we have
      $μ_2(\pa) = μ_3(\pa) = \memo(\pa,\ret(v))$.
      Hence we have shown that $μ_1 \forcesto μ_3$.
    \item \textbf{Case $μ_1(\pa) = μ_2(\pa) \not= μ_3(\pa)$}:
      % Assume μ1(a)=μ2(a), μ1→μ2, μ2(a) /= μ3(a), μ2→μ3
      % Have <μ2(a),μ2>⇓<v,μ2'>, μ2'→μ3, μ3(a) = ...(ret(v)) From μ2(a) /= μ3(a), μ2→μ3
      % Have <μ1(a),μ2>⇓<v,μ2'> From μ1(a)=μ2(a) and <μ2(a),μ2>⇓<v,μ2'>
      % Have <μ1(a),μ1>⇓<v,μ1'>, μ1'→μ2' From μ1→μ2, μ1(a) Speculate, <μ1(a),μ2>⇓<v,μ2'>
      % Have μ1 /= μ1' From W.l.o.g. Obs2, μ1'→μ2'→μ3 (and the fact that μ1/=μ3, so any of the three steps must be a proper one)
      % Have m(μ1') < m(μ1) From μ1 /= μ1'
      % Have m(μ1')-m(μ3) < m(μ1)-m(μ3) From m(μ1') < m(μ1)
      % Have μ1'→μ3 From μ1'→μ2',μ2'→μ3 and WFI(m(μ1')-m(μ3) < m(μ1)-m(μ3))
      % Have μ1→μ3 From <μ1(a),μ1>⇓<v,μ1'>, μ3(a)=...(ret(v))..., μ1'→μ3
      Then there exists $v,μ'_2$ such that $\bigstep{μ_2(\pa)}{μ_2}{v}{μ'_2}$ and
      $μ_3(\pa) = \memo(\pa, \ret(v))$ as well as $μ'_2 \forcesto μ_3$.
      We know that $μ_1(\pa) = μ_2(\pa)$, so $\bigstep{μ_1(\pa)}{μ_2}{v}{μ'_2}$.
      Since $μ_1(\pa)$ is lazy and well-addressed \wrt $μ_1$ and $μ_1 \forcesto
      μ_2$, we get $\bigstep{μ_1(\pa)}{μ_1}{v}{μ'_1}$ such that $μ_1' \forcesto
      μ_2'$ by the Speculate property.

      Since $μ_1 \not= μ_3$, some step in the chain
      $μ_1 \forcesto μ_1' \forcesto μ_2' \forcesto μ_3$ must be proper.
      The case $μ_1 = μ_2'$ follows directly from $μ_1 = μ_2' \forcesto μ_3$.
      Otherwise, when $μ_1 = μ_1'$ we have $μ_1' \not= μ_2'$ and by observation (2)
      we find $μ_1''$ such that $μ_1' \not= μ_1''$ and $μ_1'' \forcesto μ_2$,
      leading to a similar situation as when $μ_1 \not= μ_1'$.

      So without loss of generality, we assume $μ_1 \not= μ_1'$.
      From that we have $m(μ'_1)<m(μ_1)$, so by well-founded induction, we can
      combine $μ'_1 \forcesto μ_2'$ and $μ_2' \forcesto μ_3$ to
      $μ'_1 \forcesto μ_3$.
      (This step is the reason why we need the termination measure:
      The recursion into $μ'_1 \forcesto μ'_2$ is not structural.)
      Since we also have $μ_3(\pa) = \memo(\pa, \ret(v))$ and
      $\bigstep{μ_1(\pa)}{μ_1}{v}{μ'_1}$, we can show that $μ_1 \forcesto μ_3$.
  \end{itemize}
\end{proof}

\begin{corollary}
  $(\forcesto)$ is a partial order on lazy heaps.
\end{corollary}

And now we finally prove that $\semevt{\wild}$ indeed produces a lazy element:

\begin{theoremrep}
  \label{thm:semevt-lazy}
  For all environments $ρ$ and expressions $\pe$, $\semevt{\pe}_ρ$ is a lazy
  element with address domain $\rng(ρ)$.
\end{theoremrep}
\begin{proof}
  It is not hard to see that $\semevt{\pe}_ρ(μ)$ is indeed defined whenever
  $\rng(ρ) ⊆ \dom(μ)$ by induction on $\pe$.
  Conversely, $\semevt{\pe}_ρ(μ)$ might even be defined for some $μ$
  with $\dom(μ) ⊂ \rng(ρ)$.
  That might happen when $\pe$ is dead in one of its free
  variables, for example.
  Of course it is simple to stricten the definition of $\semevt{\wild}$ such
  that it is indeed undefined in these cases (or prohibited by the type system
  as in our formalisation), obscuring its presentation.
  From now on we assume that is actually the case, thus proving that
  $\semevt{\pe}_ρ(μ)$ is defined if and only if $\rng(ρ) ⊆ \dom(μ)$
  and showing the Address Domain property that encodes our previous hand-wavy
  assumption about well-addressedness.

  We show the other properties by induction on $\pe$.
  \begin{itemize}
    \item \textbf{Case $\px$}:
      Then $\fn{\wild}{\stuckend{}}$ case is easy to see, so let $\pa = ρ(\px)$.

      To show that $\fn{μ}{\LookupE(\pa) \cons μ(\pa)(μ)}$ is lazy,
      it suffices to show that $\fn{μ}{μ(\pa)(μ)}$ is.

      We begin with the Forces property.
      So let $μ$ be a lazy input heap with $\pa ∈ \dom(μ)$.
      (The undefined case is boring, because the Forces property holds trivially.)
      By laziness, we know that $μ(\pa) = \memo(\pa,d)$ for some lazy $d$
      and that $d$ is defined on $μ$.
      Furthermore, $\bigstep{d}{μ}{v}{μ'}$ for suitable lazy $v,μ'$,
      and thus $\bigstep{μ(\pa)}{μ}{v}{μ'[\pa↦\memo(\pa,\ret(v))]}$.
      Thus it is easy to see that $μ \forcesto μ'[\pa↦\memo(\pa,\ret(v))]$.

      The Postpone and Speculate property follow quite simply, because the
      updated heap entry is constant in all cases.

    \item \textbf{Case $\Lam{px}{\pe'}$}:
      For the Forces property, we assume a lazy $μ$ such that
      $\bigstep{\semevt{\pe}_ρ}{μ}{\FunV(f)}{μ}$ holds for
      $f \triangleq \fn{\pa}{\AppEE(\px↦\pa) \cons \semevt{\pe'}_{ρ[\px↦\pa]}}$.
      We have $μ \forcesto μ$ by reflexivity.
      To show that $\FunV(f)$ is indeed a lazy value, we fix some address $\pa$ and
      show that $f(\pa)$ is lazy by induction, so $\FunV(f)$ is a lazy value.
      The Postpone and Speculate properties follow by assumption.

    \item \textbf{Case $K~\many{\px}$}:
      Similar to the lambda case.

    \item \textbf{Case $\pe'~\px$}:
      The first argument to $\apply$,
      $d \triangleq \semevt{\pe'}_ρ$, is lazy by the induction hypothesis.

      The interesting case is when $\bigstep{d}{μ}{\FunV(f)}{μ'}$.
      $\FunV(f)$ is lazy by the Forces property of $d$ and then
      so is $f(ρ(\px))$.

      Hence the whole $\apply$ form is lazy and prepending the $\AppIE$ event
      does not change that because it does not affect the heap.

    \item \textbf{Case $\Case{\pe_s}{\Sel[r]}$}:
      Similar to the application case.

    \item \textbf{Case $\Let{\px}{\pe_1}{\pe_2}$}:
      $d_{\pe_i} \triangleq \semevt{\pe_i}_{ρ'}$ are lazy by induction.
      Now let $μ$ be lazy and consider $\semevt{\pe}_ρ(μ)$.
      Then $μ[\pa↦\memo(\pa,d_{\pe_1})]$ is lazy and we see that
      $μ \forcesto μ[\pa↦d_{\pe_1}]$ because $\pa \not∈ \dom(μ)$.
      Now we can apply transitivity to the Forces property of the lazy
      $d_{\pe_2}$.
      The Postpone and Speculate properties follow by transitivity as well.
  \end{itemize}
\end{proof}

This result justifies our tacit assumption from now on that all elements $d$ are lazy.

\subsection{Compositionality and Contextual Equivalence}

Compositionality is an important property of a semantics, enabling local
reasoning about terms.
Roughly, when a semantics is compositional, the denotation of an expression
is a function of the meaning of its subexpressions.
The ``is a function of'' qualifier is most often understood syntactically
in terms of a property of \emph{contexts}.

We follow \citet{MoranSands:99} and define \emph{evaluation contexts} $\pE$%
\footnote{In \Cref{defn:deadness2} we already used the term ``evaluation
context'' to denote small-step machine components $(ρ,μ,κ)$ rather than
$\pE$. \citet{MoranSands:99} prove that both notions are equivalent, so this
overload is justified.}
with holes $\hole$ in order to formalise compositionality.
Then $\pE[\pe]$ denotes an expression where the hole in $\pE$ has been replaced
with $\pe$, expressing that the bigger expression $\pE[\pe]$ is a (linear)
function of $\pe$.
\[\begin{array}{rcl}
  \pE & ::=  & \hole \mid \pE~\px \mid \Let{\px}{\pe}{\pE} \mid \Let{\px}{\pE_1}{\pE_2[\px]} \mid \Case{\pE}{\Sel[r]} \\
\end{array}\]

\begin{lemmarep}[$\semevt{\wild}$ is compositional]
  \label{thm:semevt-comp}
  Let $\pe_1, \pe_2$ be expressions such that
  for all environments $ρ$, $\semevt{\pe_1}_ρ = \semevt{\pe_2}_ρ$.
  Then for all evaluation contexts $\pE$ and environments $ρ$, we have
  $\semevt{\pE[\pe_1]}_{ρ} = \semevt{\pE[\pe_2]}_{ρ}$.
\end{lemmarep}
\begin{proof}
  By induction on $\pE$. The interesting case is the $\hole$ case where we
  apply the assumption $\semevt{\pe_1}_ρ = \semevt{\pe_2}_ρ$.
\end{proof}

Compositionality means we can factor $\semevt{\pE[\pe]}$ into two functions
such that $\semevt{\pE[\pe]} = \semevt{\pE}(\semevt{\pe})$, thus
recovering a semantics for contexts
\[
  \semevt{\pE} \colon ((\Var \pfun \Addresses) → \EventD) → ((\Var \pfun \Addresses) → \EventD)
\]
This function can easily be derived from $\semevt{\pe}$; we give the full
definition of this function in the Appendix.

\begin{toappendix}
\begin{figure}
\[\begin{array}{rcl}
  \multicolumn{3}{c}{ \ruleform{ \semevt{\pE} \colon ((\Var \pfun \Addresses) → \EventD) → ((\Var \pfun \Addresses) → \EventD) } } \\
  \\[-0.75em]
  \semevt{\hole}(S)_ρ(μ)       & = & S_ρ(μ) \\
  \\[-0.75em]
  \semevt{\pE~\px}(S)_ρ(μ)   & = & \begin{cases}
    \AppIE(ρ(x)) \cons \apply(\semevt{\pE}(S)_ρ, ρ(\px))(μ) & \px ∈ \dom(ρ) \\
    \stuckend{}  & \text{otherwise} \\
  \end{cases} \\
  \\[-0.75em]
  \semevt{\Let{\px}{\pe}{\pE}}(S)_ρ(μ) & = &
    \begin{letarray}
      \text{let} & ρ' = ρ[\px ↦ \pa] \quad \text{where $\pa \not∈ \dom(μ)$} \\
                 & d_1^\later = \semevt{\pe}_{ρ'} \\
      \text{in}  & \BindE(\px,\pa↦d_1^\later) \cons \semevt{\pE}(S)_{ρ'}(μ[\pa ↦ \memo(\pa,d_1^\later)])
    \end{letarray} \\
  \\[-0.75em]
  \semevt{\Let{\px}{\pE_1}{\pE_2[x]}}(S)_ρ(μ) & = &
    \begin{letarray}
      \text{let} & ρ' = ρ[\px ↦ \pa] \quad \text{where $\pa \not∈ \dom(μ)$} \\
                 & d_1^\later = \semevt{\pE_1}(S)_{ρ'} \\
      \text{in}  & \BindE(\px,\pa↦d_1^\later) \cons \semevt{\pE_2[x]}_{ρ'}(μ[\pa ↦ \memo(\pa,d_1^\later)])
    \end{letarray} \\
  \\[-0.75em]
  \semevt{\Case{\pE}{\Sel[r]}}(S)_ρ(μ) & = &
    \begin{letarray}
      \text{let} & \alts = \fn{(K_i, \many{\pa})}{\CaseEE(K_i,\many{\px_i↦\pa}) \cons \semevt{\pe_{r_i}}_{ρ[\many{\px_i↦\pa}]}} \\
      \text{in} & \CaseIE(\semevt{\pE}(S)_ρ) \cons \select(\semevt{\pE}(S)_ρ, \alts)(μ)  \\
    \end{letarray}
\end{array}\]
\caption{Eventful Trace Semantics for Evaluation Contexts}
\label{fig:semevt-ctx}
\end{figure}
\end{toappendix}

We can extend the meaning of compositionality to equivalence relations
on expressions:

\begin{definition}[Compositionality of $\semevt{\wild}$]
  Let $\cong$ be an equivalence relation on expressions.
  $\cong$ is \emph{compositional} if and only if for all $\pe_1,\pe_2$,
  $\pe_1 \cong \pe_2$ implies $\pE[\pe_1] \cong \pE[\pe_2]$ for all evaluation
  contexts $\pE$.
\end{definition}

In this sense, definitional equality $\fn{\pe_1\,\pe_2}{\semevt{\pe_1}_ρ = \semevt{\pe_2}_ρ}$
is compositional by \Cref{thm:semevt-comp}.
It is also well-known that \emph{contextual equivalence}~\citep{Morris:69} is
compositional:

\begin{definition}[Contextual equivalence, as in \citep{MoranSands:99}]
  Two expressions $\pe_1,\pe_2$ are \emph{contextually equivalent}, written
  $\pe_1 \equiv \pe_2$, if their termination behavior coincides
  in all contexts, \eg, for all closed evaluation contexts $\pE$ it is
  \[
    \len(\semevt{\pE[\pe_1]}_{[]}([])) = ω \Longleftrightarrow \len(\semevt{\pE[\pe_2]}_{[]}([])) = ω
  \]
  where $\len$ is the length function from \Cref{defn:length}.
\end{definition}

The definition of \citet{MoranSands:99} is in terms of a transition system like
$(\smallstep)$, but adequacy (\Cref{thm:semvan-adequate}) guarantees that the two
notions coincide.

\begin{lemmarep}[Contextual equivalence is compositional]
  Let $\pe_1, \pe_2$ be expressions such that
  $\pe_1 \equiv \pe_2$.
  Then for all evaluation contexts $\pE$, we have
  $\pE[\pe_1] \equiv \pE[\pe_2]$.
\end{lemmarep}
\begin{proof}
  Immediate, because $\pE[\pE_2[\hole]]$ is just another context in which
  contextually equivalent expressions are contextually equivalent.
\end{proof}

\subsection{A Useful Semantic Equivalence Relation}

Contextual equivalence allows to prove many transformations compatible by
high-level, first-order equational reasoning on a syntactic level.
Many equations are folklore, such as any $(\impequiv)$ law in
\citet{MoranSands:99}.
Some laws, such as
\[
  \Let{\px}{\pe_1}{\pE[\pe_2]} \equiv \pE[\Let{\px}{\pe_1}{\pe_2}]
\]
come with a condition; in this case that $\px$ does not occur freely in $\pE$.

To prove such laws, one must unfold the definition of $\equiv$ and attempt
a lower level proof based on the underlying semantics, exploiting the condition
by interpreting it semantically.

We will see a concrete example in the next section, where we maintain the
invariant that an address is dead in a heap and any arguments in order to
justify certain rewrites.
We found it far simpler to express this invariant in the semantic domain
(\eg, as a predicate on environments and heaps) rather than in the syntactic
domain (\eg, as a predicate on the evaluation contexts).%
\footnote{For the curious: We found proving \Cref{thm:dead-let} surprisingly
difficult using irrelevance as defined in \Cref{thm:dead-irrelevant} as the
definition of deadness.
It is necessary to strengthen the definition by allowing arbitrary ``dead''
evaluation contexts between $\Let{\px}{\pe_i}{\hole}$ and $\pe$, for some
notion of ``dead''.}
Hence it is crucial that we have a way to express semantic demands on the
evaluation contexts to consider in $(\equiv)$.

A first step then is to define conditional contextual equivalence:
\begin{definition}[Conditional contextual equivalence]
Given an arbitrary property $P(\pE)$ on evaluation contexts, we write
$P(\pE_\cong) ⊦ \pe_1 \equiv \pe_2$ to mean
\[
  \forall \pE.\ P(\pE) \Longrightarrow \len(\semevt{\pE[\pe_1]}_{[]}([])) = ω \Longleftrightarrow \len(\semevt{\pE[\pe_1]}_{[]}([])) = ω
\]
\end{definition}

Clearly,
$\mathsf{true} ⊦ \pe_1 \equiv \pe_2 \Longleftrightarrow \pe_1 \equiv \pe_2$,
hence we usually omit a tautological antecedent.

Orthogonally, we can capitalise on our new $\semevt{\pE}$ function to derive
a more ``semantic'' equivalence relation $(\cong)$ from the ``syntactic''
equivalence $(\equiv)$ on expressions $\Exp$:
\[
  S_1 \cong S_2 \triangleq \forall \pE.\ \len(\semevt{\pE}(S_1)_{[]}([])) = ω \Longleftrightarrow \len(\semevt{\pE}(S_2)_{[]}([])) = ω
\]
$(\cong)$ is an equivalence relation on semantic objects with
functionality $S \colon (\Var \pfun \Addresses) → \EventD$, with $\semevt{\pe}$
being an example of such an object.
In fact, we have $\pe_1 \equiv \pe_2$ if and only if $\semevt{\pe_1} \cong
\semevt{\pe_2}$.

Both ideas above can be combined into the following conditional semantic
equivalence:

\begin{definition}[Semantic equivalence relation]
\label{defn:sem-equiv}
Given an arbitrary property $P(ρ,μ,A)$ on environments, heaps and a list of
addresses occuring in applications, we write
$P(ρ_\cong,μ_\cong,A_\cong) ⊦ S_1 \cong S_2$ to mean
\[
  \forall \pE.\ P(ρ(\pE),μ(\pE),A(\pE)) \Longrightarrow \len(\semevt{\pE}(S_1)_{[]}([])) = ω \Longleftrightarrow \len(\semevt{\pE}(S_2)_{[]}([])) = ω,
\]
where $ρ(\pE)$ denotes the environment in which $\semevt{\pE}(S)_{[]}([])$ calls
(an arbitrary) $S$; $μ(\pE)$ denotes the heap and $A(\pE)$ denotes the list of
addresses of $\px$ in frames of the form $\hole~\px$,
from innermost to outermost.
\end{definition}

We have
$\mathsf{true} ⊦ \semevt{\pe_1} \cong \semevt{\pe_2} \Longleftrightarrow \pe_1 \equiv \pe_2$
and omit tautological antecedents, as before.

\begin{abbreviation}
\label{defn:sem-equiv-abbrev}
Any term standing in for a semantic object that is free in $ρ_\cong$ and
$μ_\cong$ is lambda-abstracted over.
For example, the expanded form of $\semevt{\pe_1}_{ρ_\cong}(μ_\cong[\pa↦d_1])
\cong \semevt{\pe_2}_{ρ_\cong}(μ_\cong[\pa↦d_2])$
is
\[
  \mathsf{true} ⊦ (\fn{ρ_\cong\,μ_\cong}{\semevt{\pe_1}_{ρ_\cong}(μ_\cong[\pa↦d_1])}) \cong (\fn{ρ_\cong\,μ_\cong}{\semevt{\pe_2}_{ρ_\cong}(μ_\cong[\pa↦d_2])}).
\]
\end{abbreviation}

Now we can express conditions such as ``$\pa$ is fresh'' by writing
$\pa \not∈ \dom(μ_\cong) ⊦ \semevt{\pe_1} \cong \semevt{\pe_2}$.
%Additionally, $P$ may be folded into the arguments of $S_i$, \ie, $S_1(ρ')(μ')
%\cong S_2(ρ')(μ')$ means $ρ_\cong=ρ' \wedge μ_\cong=μ' ⊦ S_1 \cong S_2$.

It would be interesting to recover a semantic equivalence relation that doesn't
need to appeal to $\semevt{\pE}$, preferrably on $\EventD$ directly.
In an earlier version of this work, we attempted to give such a definition;
an endeavour that we ultimately abandoned due to lacking familiarity with the
topic, complexity and diminishing confidence in its correctness.
The reader may find the alternative version of this Section in the Appendix.

Since we essentially stick to syntactic contextual equivalence, we navigate
around questions of \emph{full abstraction}~\citep{Plotkin:77}.
Clearly, $(\equiv)$ is fully abstract and hence so is $\cong$ when semantic
objects are restricted to $\rng(\semevt{\wild})$.

%\begin{toappendix}
%\subsection{A Useful Program Equivalence}
%
%\begin{figure}
%\[\begin{array}{c}
% \ruleform{ \fin(τ) \qquad A ⊦ τ_1 \sim τ_2 \qquad A ⊦ μ_1 \approx μ_2 \qquad d_1 \equiv d_2}
% \\
% \\[-0.5em]
% \inferrule*[right=\finstuck]
%    {\quad}
%    {\fin(\stuckend)}
% \quad
% \inferrule*[right=\fingood]
%    {\quad}
%    {\fin(\goodend{v,μ})}
% \quad
% \inferrule*[right=\fincons]
%    {\fin(τ)}
%    {\fin(a \cons τ)}
% \\
% \\[-0.5em]
% \inferrule*[right=\eqlrcons]
%    {\later (A ⊦ τ_1 \sim τ_2)}
%    {A ⊦ \wild \cons τ_1 \sim \wild \cons τ_2}
% \quad
% \inferrule*[right=\eqrcons]
%    {\later (A ⊦ τ_1 \sim τ_2) \quad \fin(τ_2)}
%    {A ⊦ τ_1 \sim \wild \cons τ_2}
% \quad
% \inferrule*[right=\eqlcons]
%    {\later (A ⊦ τ_1 \sim τ_2) \quad \fin(τ_1)}
%    {A ⊦ \wild \cons τ_1 \sim τ_2}
% \\
% \\[-0.5em]
% \inferrule*[right=\eqstuck]
%    {\quad}
%    {A ⊦ \stuckend{} \sim \stuckend{}}
% \quad
% \inferrule*[right=\eqcon]
%    {\later (\many{A ⊦ μ_1(\pa_1)(μ_1) \sim μ_2(\pa_2)(μ_2)})}
%    {A ⊦ \goodend{\ConV(K, \many{\pa_1}), μ_1} \sim \goodend{\ConV(K, \many{\pa_2}), μ_2}}
% \\
% \\[-0.5em]
% % We need later (coinduction) here rather than induction, because otherwise we
% % have no induction hypothesis to prove the Fun case of
% % "d lazy, μ1~>μ2 => d(μ1)===d(μ2)" with
% \inferrule*[right=\eqfun]
%    {\forall \pa ∈ A.\  \later (A ⊦ f_1(\pa)(μ_1) \sim f_2(\pa)(μ_2))}
%    {A ⊦ \goodend{\FunV(f_1), μ_1} \sim \goodend{\FunV(f_2), μ_2}}
% \quad
% \inferrule*[right=\eqfun]
%    {\forall \pa ∈ A.\  \later (A ⊦ f_1(\pa)(μ_1) \sim f_2(\pa)(μ_2))}
%    {A ⊦ \goodend{\FunV(f_1), μ_1} \sim \goodend{\FunV(f_2), μ_2}}
% \\
% \\[-0.5em]
% % We need the frame rule like ∪ \dom(μ') because otherwise the predicate is too
% % weak. Consider
% %   [a1 ↦ ... Fun(λa. if μ(a) then tt else ff) ..., a2 ↦ ret(tt)]
% %   =
% %   [a1 ↦ ... Fun(λa. if μ(a) then tt else tt) ..., a2 ↦ ret(tt)]
% % If we don't allow arbitrary extension, we will equate these two heaps.
% % Booo! This means we can't extend with [a3 ↦ ret(ff)], because we may suddenly
% % probe the entry at a1 by calling it with a3, exposing the previously dead
% % code path.
% % VERY TRICKY
% \inferrule*[right=\eqheap]
%    {\forall \pa \in A.\ \later(\forall μ'.\ A ∪ \dom(μ') ⊦ μ_1(\pa)(μ_1 \oplus μ') \sim μ_2(\pa)(μ_2 \oplus μ'))}
%    {A ⊦ μ_1 \approx μ_2}
% \\
% \\[-0.5em]
% \inferrule*[right=\eqdenot]
%    {\forall A,μ_1,μ_2.\ \adom(d_i) ⊆ A \wedge A ⊦ μ_1 \approx μ_2  ⟹  \forall μ'.\ A ∪ \dom(μ') ⊦ d_1(μ_1 \oplus μ') \sim d_2(μ_2 \oplus μ')}
%    {d_1 \equiv d_2}
%\end{array}\]
%\caption{Semantic equivalence relation on lazy elements}
%  \label{fig:sem-equiv}
%\end{figure}
%
%Consider the two expressions $\pe_1 \triangleq \Let{x}{\ttrue}{\ttrue}$ and
%$\pe_2 \triangleq \Let{x}{\ffalse}{\ttrue}$.
%For all intents and purposes, these two expressions are equivalent.
%Indeed, they equate under $\semscott{\wild}$, suggesting that $x$ is dead
%according to \Cref{defn:deadness}.
%
%However, the definitional equality on the lazy domain $\EventD$ is \emph{too
%fine}:
%\[\begin{array}{rclcl}
%  \semevt{\pe_1}_{[]}([])
%  & = & \BindE(x,\pa_1↦\semevt{\ttrue}_{...}) \cons \goodend{\ConV(\ttrue),[\pa_1↦\semevt{\ttrue}_{...}]} \\
%  & \not= & \BindE(x,\pa_1↦\semevt{\ffalse}_{...}) \cons \goodend{\ConV(\ttrue),[\pa_1↦\semevt{\ffalse}_{...}]}
%  & = & \semevt{\pe_2}_{[]}([])
%\end{array}\]
%It would be reasonable to abstract away the contents of the trace to get a
%coarser equivalence, thus eliminating the difference in $\BindE$ actions.
%However, that still leaves the difference in heap entries such as $\pa_1$ which
%will never be looked at!
%Since the heap entry for $\pa_1$ was introduced while executing $\pe_1$/$\pe_2$,
%we will call them \emph{internal} to the trace $\semevt{\pe_i}_{[]}([])$;
%any other heap entries are \emph{public}.
%It is prudent for the observer to ignore internal entries.
%
%That is the essence of what the \emph{semantic equivalence relation} $(\equiv)$
%defined on lazy elements in \Cref{fig:sem-equiv} does.
%It is coarse enough to equate the example above, but still finer than contextual
%equivalence, as we shall see.
%
%The key is its observer model for function values, which necessitates the
%\emph{address space} parameter $A ⊆ \Addresses$ in $\wild ⊦ \wild \sim \wild$ to
%track public addresses.
%Consider a successful evaluation $\bigstep{d_i}{μ_i}{\FunV(f_i)}{μ_i'}$, as in
%\[\begin{array}{rclcl}
%  \semevt{\Let{t}{\ttrue}{\Lam{z}{t}}}_{[]}([])
%  & = & ... \cons \goodend{\FunV(\fn{\wild}{\fn{μ}{...μ(\pa_1)...}}),[\pa_1↦d_t]} \\
%  & \equiv & ... \cons \goodend{\FunV(\fn{\wild}{\fn{μ}{...μ(\pa_2)...}}),[\pa_1↦d_f,\pa_2↦d_t]} \\
%  & = & \semevt{\Let{f}{\ffalse}{\Let{t}{\ttrue}{\Lam{z}{t}}}}_{[]}([])
%\end{array}\]
%The denotations of the two expressions are not definitionally equivalent in the final heap,
%yet they are semantically equivalent.
%To see that, we have to relate the heap entries in $\pa_1$ and $\pa_2$, which
%only succeeds when the internal entries in $μ_i'$ are retained.
%So $(\sim)$ may not simply discard final heaps and carry
%on with the initial one.
%
%Furthermore, some detail must be hidden from the observer who may probe
%functions for equality by supplying (nearly) any argument denotation they wish
%via the heap.
%The following example illustrates how exactly such argument denotations should be
%restricted:
%\[\begin{array}{rclcl}
%  \semevt{\Let{x}{\ttrue}{\Lam{y}{y}}}_{[]}([])
%  & = & ... \cons \goodend{\FunV(\fn{\pa}{\fn{μ}{...μ(\pa)...}}),[\pa_1↦d_t]} \\
%  & \equiv & ... \cons \goodend{\FunV(\fn{\pa}{\fn{μ}{...μ(\pa)...}}),[\pa_1↦d_f]} \\
%  & = & \semevt{\Let{x}{\ffalse}{\Lam{y}{y}}}_{[]}([]),
%\end{array}\]
%In both cases, the function value $\FunV(\fn{\pa}{\fn{μ}{...μ(\pa)...}})$ is to
%be probed by the observer with an address of their choosing.
%If the observer was given free reign, they could choose $\pa_1$ and thus be able
%to observe the different heaps.
%Fortunately, such exploits can be prohibited by requiring $\pa∈A$ in $\eqfun$,
%ruling out the internal address $\pa_1 \not∈ A$.
%This is not too grave a restriction on the observer, because they may
%pre-allocate any denotation into the heap and invoke $(\equiv)$ at an $A$ that
%contains the newly allocated address.
%The $A \vdash μ_1 \approx μ_2$ judgment ensures that heaps have
%compatible entries at addresses in $A$.
%Equivalent heaps guarantee that their public entries are equivalent up to
%arbitrary extension $μ'$ of heaps, expressed with a disjoint extension operator
%$(\oplus)$ reminiscent of the frame rule in separation logic~\citep{Reynolds:02}.%
%\footnote{Technically, the $μ'$ is not a lazy heap and should rather be
%thought of as a list of lazy bindings $[\many{\pa↦d}]$, each of which may
%reference addresses in $A$.}
%%Framing is crucial to show that heap extension preserves equivalence of heaps.
%
%\begin{lemma}[Weakening of address spaces]
%  \label{thm:weaken-address-space}
%  Let $A_1,A_2$ be address spaces such that $A_1 ⊆ A_2$. \\
%  For all traces $τ_1,τ_2$, if $A_2 ⊦ τ_1 \sim τ_2$ then $A_1 ⊦ τ_1 \sim τ_2$.
%\end{lemma}
%\begin{proof}
%  Take note that the check $\pa ∈ A$ occurs in negative
%  position in $\wild ⊦ \wild \sim \wild$ and $A$ is never used anywhere else.
%  Intuitively, the smaller $A$, the fewer $\pa$s the caller is allowed to
%  ``probe'' $\FunV$ values with and the easier it is to prove bisimulation.
%\end{proof}
%
%\begin{theorem}
%  \label{thm:sim-equiv}
%  For any address space $A$, $A ⊦ \wild \sim \wild$ is an equivalence relation on lazy traces.
%\end{theorem}
%\begin{proof}
%Reflexivity follows by straightforwardly by Löb induction.
%Symmetry does so as well, with the twist that the rule applications of
%$\eqlcons$ and $\eqrcons$ need to be swapped.
%
%For transitivity, we assume
%$A ⊦ τ_1 \sim τ_2$, $A ⊦ τ_2 \sim τ_3$ to show $A ⊦ τ_1 \sim τ_3$ by Löb
%induction, \eg, assuming that
%\[
%  \later(A ⊦ τ_1 \sim τ_2 \wedge A ⊦ τ_2 \sim τ_3 \Longrightarrow A ⊦ τ_1 \sim τ_3)
%\]
%for all $τ_1,τ_2,τ_3$.
%By cases on the last rule applied to $A ⊦ τ_1 \sim τ_2$.
%\begin{itemize}
%  \item \textbf{Case }$\eqlcons$:
%    Then $τ_1 = \wild \cons τ_1'$ and $\later (A ⊦ τ_1' \sim τ_2)$.
%    We can apply the induction hypothesis to get $\later (A ⊦ τ_1' \sim τ_3)$
%    and re-apply $\eqlcons$.
%  \item \textbf{Case }$\eqrcons$:
%    Then $τ_2 = \wild \cons τ_2'$, $\fin(τ_2')$ and $\later (A ⊦ τ_1 \sim τ_2')$.
%    By rule inversion on $A ⊦ τ_2 \sim τ_3$, either $\eqlcons$, $\eqrcons$ or
%    $\eqlrcons$ applies.
%
%    If we unpack $\eqlrcons$, we get $\later (A ⊦ τ_2' \sim τ_3')$ for
%    some $τ_3'$ to which we apply the induction hypothesis to get
%    $\later (A ⊦ τ_1 \sim τ_3')$, which we wrap up with $\eqrcons$ to show the goal.
%
%    If we unpack $\eqrcons$, we get $\later (A ⊦ τ_2 \sim τ_3')$ for
%    some $τ_3'$ to which we apply the induction hypothesis to get
%    $\later (A ⊦ τ_1 \sim τ_3')$, which we wrap up with $\eqrcons$ to show the goal.
%    (NB: We use $A ⊦ τ_1 \sim τ_2$ in that case, not the unpacked
%    $\later (A ⊦ τ_1 \sim τ_2')$.)
%
%    Otherwise, we unpack $\eqlcons$ and get $\later (A ⊦ τ_2' \sim τ_3)$.
%    We proceed by induction on $\fin(τ_2')$ with the hypothesis
%    \[
%      P(τ) = A ⊦ τ_1 \sim τ \wedge A ⊦ τ \sim τ_3 \Longrightarrow A ⊦ τ_1 \sim τ_3
%    \]
%    \begin{itemize}
%      \item \textbf{Case }$τ_2' = \finstuck$:
%        Then $τ_1$ and $τ_3$ must be ultimately stuck as well. The derivation
%        for $A ⊦ τ_1 \sim τ_3$ can be constructed by first doing all $\eqlcons$
%        steps in $A ⊦ τ_1 \sim \stuckend$ and then all $\eqrcons$ steps in $A ⊦
%        \stuckend \sim τ_3$.
%      \item \textbf{Case }$τ_2' = \goodend{v,μ'}$:
%        Then $τ_1$ and $τ_3$ evaluate to the same value as $τ_2'$. The goal
%        follows by applying the (Löb) induction hypothesis to the ultimate
%        applications of $\eqfun$ and $\eqcon$ cases, and re-applying $\eqlcons$
%        and $\eqrcons$ steps as in the diverging case.
%      \item \textbf{Case }$τ_2' = \wild \cons τ_2''$:
%        As before, the cases where $τ_1$ or $τ_3$ make a step at ``the front or back''
%        (by $\eqlcons$ on $A ⊦ τ_1 \sim τ_2'$ or $\eqrcons$ on $A ⊦ τ_2' \sim
%        τ_3$, or $\eqlrcons$ on either side) follow by Löb induction.
%
%        Otherwise, we recurse along the $\fin(τ_2')$ predicate and invoke the induction
%        hypothesis $P(τ_2'')$, re-applying the $\eqrcons$ on the left and the $\eqlcons$
%        rule on the right.
%    \end{itemize}
%  \item \textbf{Case }$\eqlrcons$:
%    Apply the induction hypothesis to $\later (A ⊦ τ_1' \sim τ_2')$.
%  \item \textbf{Case }$\eqfun$:
%    By rule inversion on $A ⊦ τ_2 \sim τ_3$, $\eqfun$ must apply.
%    (Note that $\eqrcons$ has been handled in a previous case.)
%    The rest is a matter of applying the inductive hypothesis.
%  \item \textbf{Case }$\eqcon$: Similar.
%  \item \textbf{Case }$\eqstuck$: Similar.
%\end{itemize}
%\end{proof}
%
%It follows that $(\approx)$ is an equivalence relation on lazy heaps as well.
%
%Evaluating lazy elements on heaps that force to each other yields semantically equivalent traces:
%
%\begin{lemma}
%  \label{thm:lazy-force-bisimilar}
%  Let $μ_1,μ_2$ be lazy heaps with $μ_1 \forcesto μ_2$ and $d$ a lazy element such that $\dom(μ_{1}) ⊆ \adom(d)$.
%  Then $\dom(μ_1) ⊦ d(μ_1) \sim d(μ_2)$.
%\end{lemma}
%\begin{proof}
%By Löb induction.
%
%If either $d(μ_1)$ or $d(μ_2)$ is ultimately stuck or diverges, then so
%is the other by the Speculate and Postpone property.
%In that case, we see that $\dom(μ_1) ⊦ d(μ_1) \sim d(μ_2)$.
%
%Likewise, if either $\bigstep{d}{μ_1}{v}{μ_1'}$ or $\bigstep{d}{μ_2}{v}{μ_2'}$
%then both judgments hold by the Speculate and Postpone properties (note
%that $d$ is defined on $μ_1$ because $\dom(μ_1) ⊆ \adom(d)$) and we have
%$μ_1' \forcesto μ_2'$.
%Hence it suffices to show
%${\dom(μ_1) ⊦ \goodend{v,μ_1'} \sim \goodend{v,μ_2'}}$.
%
%For the $v=\FunV(f)$ case, we fix an arbitrary $\pa ∈ \dom(μ_1)$ and have
%to show that $\later (\dom(μ_1) ⊦ f(\pa)(μ_1') \sim f(\pa)(μ_2'))$.
%But $f(\pa)$ is lazy, and
%we have $\later (\many{\dom(μ_1') ⊦ f(\pa)(μ_1') \sim f(\pa)(μ_2')})$
%by the induction hypothesis applied to $μ_1' \forcesto μ_2'$.
%Again, we may relax the address space from $\dom(μ_1')$ to $\dom(μ_1)$ via
%\Cref{thm:weaken-address-space}.
%
%For the $v=\ConV(K,\many{\pa})$ case, we have to show
%$\later (\many{\dom(μ_1) ⊦ μ_1'(\pa)(μ_1') \sim μ_2'(\pa)(μ_2')})$.
%By cases over $μ_1' \forcesto μ_2'$:
%\begin{itemize}
%  \item \textbf{Case $μ_1'(\pa) = μ_2'(\pa)$}:
%    Then we get
%    $\later (\dom(μ_1') ⊦ μ_1'(\pa)(μ_1') \sim μ_1'(\pa)(μ_2'))$ by the
%    induction hypothesis.
%    We can relax the address space from $\dom(μ_1')$ to $\dom(μ_1)$ via
%    \Cref{thm:weaken-address-space} to show the goal.
%  \item \textbf{Case $μ_1'(\pa) \not= μ_2'(\pa)$}:
%    Then we have $\bigstep{μ_1'(\pa)}{μ_1'}{v'}{μ_1''}$
%    for some $μ_1'',v'$, $μ_2'(\pa) = \memo(\pa,\ret(v'))$
%    and $μ_1'' \forcesto μ_2'$.
%    Clearly, since $μ_1'' \forcesto μ_2'$, we have
%    \[
%      \later (\dom(μ_1'') ⊦ \ret(v')(μ_1'') \sim \ret(v')(μ_2'))
%    \]
%    by the induction hypothesis.
%    But since $\bigstep{μ_1'(\pa)}{μ_1'}{v'}{μ_1''}$, we can just apply
%    rule $\eqlcons$ a finite number of times and $\eqrcons$ once to show
%    \[
%      \later (\dom(μ_1) ⊦ μ_1'(\pa)(μ_1'') \sim μ_2'(\pa)(μ_2')).
%    \]
%    (Relaxing the address space parameter to $\dom(μ_1')$.)
%    Noting that $μ_1' \forcesto μ_1''$ due to the Forces property, we get,
%    by the induction hypothesis,
%    \[
%      \later (\dom(μ_1) ⊦ μ_1'(\pa)(μ_1') \sim μ_1'(\pa)(μ_1'')).
%    \]
%    Now we apply transitivity to show the goal.
%    % This is nice, because we didn't need thm:lazy-force-approx below to show
%    % this.
%\end{itemize}
%\end{proof}
%
%% Perhaps we don't even need this one:
%%\begin{lemma}
%%  \label{thm:lazy-force-approx}
%%  Let $μ_1,μ_2$ be lazy heaps with $μ_1 \forcesto μ_2$.
%%  Then $\dom(μ_1) ⊦ μ_1 \approx μ_2$.
%%\end{lemma}
%%\begin{proof}
%%By Löb induction.
%%By rule $\eqheap$, we fix $μ'$ such that $μ_i \disjoint μ'$ and
%%$\pa ∈ \dom(μ_1)$ to show
%%\[
%%  \later(\dom(μ_1) ∪ \dom(μ') ⊦ μ_1(\pa)(μ_1 \oplus μ') \sim μ_2(\pa)(μ_2 \oplus μ'))
%%\]
%%Clearly, $μ_1 \oplus μ' \forcesto μ_2 \oplus μ'$ because the entries added
%%by $μ'$ are identical.
%%
%%We proceed by cases on $μ_1 \oplus μ' \forcesto μ_2 \oplus μ'$.
%%When $μ_1(\pa) = μ_2(\pa)$, we can apply \Cref{thm:lazy-force-bisimilar}
%%to show the goal.
%%Otherwise we have
%%$\bigstep{μ_1(\pa)}{μ_1 \oplus μ'}{v}{μ_1'}$
%%for some $v,μ_1'$, $μ_2(\pa) = \memo(\pa,\ret(v))$ and $μ_1' \forcesto μ_2 \oplus μ'$.
%%(Note that $\pa \not∈ \dom(μ')$.)
%%$μ_1' \forcesto μ_2 \oplus μ'$ and \Cref{thm:lazy-force-bisimilar} implies
%%\[
%%  \later (\dom(μ_1') ⊦ \ret(v)(μ_1') \sim \ret(v)(μ_2 \oplus μ'))
%%\]
%%and the rest is similar to the $\ConV$ case of \Cref{thm:lazy-force-bisimilar}.
%%\end{proof}
%
%Unfortunately, the notion of a lazy element we have is too weak to prove
%reflexivity of $(\equiv)$.
%Lazy elements only provide guarantees on heaps that force to each other,
%but $A ⊦ μ_1 \approx μ_2$ does not imply a forcing relation between $μ_1$ and $μ_2$.%
%\footnote{This could perhaps be fixed by parameterising the forcing relation
%over any equivalence relation such as semantic equivalence rather than
%hardcoding it for definitional equality. We abstain from such complication in
%favor of the present fix.}
%We fix that by introducing the following extensionality requirement on lazy
%elements $d$:
%
%\begin{definition}[Extensionality]
%  A lazy element $d$ is \emph{extensional} if and only if $d \equiv d$.
%\end{definition}
%
%\begin{lemma}
%  \label{thm:memo-approx-extend}
%  Let $A ⊦ μ_1 \approx μ_2$, $\pa \not∈ \dom(μ_i)$ and $d$ lazy and extensional
%  with $\adom(d) ⊆ A ∪ \{\pa\}$.
%  Then $A ∪ \{\pa\} ⊦ μ_1[\pa↦\memo(\pa,d)] \approx μ_2[\pa↦\memo(\pa,d)]$.
%\end{lemma}
%\begin{proof}
%  Let us abbreviate $μ_i' \triangleq μ_i[\pa↦\memo(\pa,d)]$.
%  We have to show
%  \[
%    \forall μ'.\ \forall \pa' \in A ∪ \{\pa\}.\ \later(A ∪ \{\pa\} ∪ \dom(μ') ⊦ μ_1'(\pa')(μ_1' \oplus μ') \sim μ_2'(\pa')(μ_2' \oplus μ')).
%  \]
%  So fix arbitrary $μ'$ and $\pa' \in A ∪ \{\pa\}$.
%  When $\pa' ∈ A$, the equivalence follows from $A ⊦ μ_1 \approx μ_2$; we simply
%  add the $\pa$ entry to $μ'$.
%  NB: This is the reason why we need the capability to frame around arbitrary
%  heap extension!
%
%  Otherwise, $\pa'=\pa$ and the goal is to show
%  \[
%     \later(A ∪ \{\pa\} ∪ \dom(μ') ⊦ \memo(\pa,d)(μ_1' \oplus μ') \sim \memo(\pa,d)(μ_2' \oplus μ')).
%  \]
%  By Löb induction, we may assume $A ∪ \{\pa\} ⊦ μ_1' \approx μ_2'$ under the
%  later modality.
%  We can apply this fact to $\memo(\pa, d) \equiv \memo(\pa, d)$ since
%  $\memo(\pa, d)$ is extensional.
%  Further instantiation at $μ'$ shows the goal.
%\end{proof}
%
%\begin{lemma}
%  \label{thm:memo-approx-equiv-one}
%  Let $μ$ be a heap and $d$ an element, both lazy and extensional.
%  For $\pa ∈ \dom(μ)$ such that $μ(\pa) \equiv \memo(\pa, d)$, we have
%  $A ⊦ μ \approx μ[\pa ↦ \memo(\pa, d)]$.
%\end{lemma}
%\begin{proof}
%  Let us abbreviate $μ_1 \triangleq μ[\pa↦\memo(\pa,d)]$.
%  We have to show
%  \[
%    \forall μ'.\ \forall \pa' \in A.\ \later(A ∪ \dom(μ') ⊦ μ(\pa')(μ \oplus μ') \sim μ_1'(\pa')(μ_1' \oplus μ')).
%  \]
%  So fix arbitrary $μ'$ and $\pa' \in A$.
%  By Löb induction, we may assume $\later(A ⊦ μ \approx μ_1)$.
%
%  When $\pa' \not= \pa$, we have $μ(\pa') = μ_1(\pa')$ and we can apply the
%  induction hypothesis to extensionality of $μ(\pa')$.
%
%  Otherwise, we have $\pa' = \pa$ and the goal is to show
%  \[
%    \later(A ∪ \dom(μ') ⊦ μ(\pa)(μ \oplus μ') \sim \memo(\pa,d)(μ_1' \oplus μ')).
%  \]
%  But we know that $μ(\pa) \equiv \memo(\pa,d)$ and can apply this fact to the
%  induction hypothesis to show the goal.
%\end{proof}
%
%\begin{corollary}
%  \label{thm:memo-approx-equiv}
%  Let $A ⊦ μ_1 \approx μ_2$, $\pa \not∈ \dom(μ_i)$ and $d_1 \equiv d_2$,
%  all heaps and elements lazy and extensional with $\adom(d_i) ⊆ A ∪ \{\pa\}$.
%  Then $A ∪ \{\pa\} ⊦ μ_1[\pa↦\memo(\pa,d_1)] \approx μ_2[\pa↦\memo(\pa,d_2)]$.
%\end{corollary}
%\begin{proof}
%  We apply \Cref{thm:memo-approx-extend} to $d_1$ and have
%  \[
%    A ∪ \{\pa\} ⊦ μ_1[\pa↦\memo(\pa,d_1)] \approx μ_2[\pa↦\memo(\pa,d_1)]
%  \]
%  By \Cref{thm:memo-approx-equiv-one}, we also have
%  \[
%    A ∪ \{\pa\} ⊦ μ_2[\pa↦\memo(\pa,d_1)] \approx μ_2[\pa↦\memo(\pa,d_2)]
%  \]
%  since $\memo(\pa,d_1) \equiv \memo(\pa,d_2)$.
%  We can combine both facts transitively to show the goal.
%\end{proof}
%
%\begin{theorem}
%  \label{thm:equiv-equiv}
%  $(\equiv)$ is an equivalence relation on lazy and extensional elements in
%  $\EventD$.
%\end{theorem}
%\begin{proof}
%Reflexivity follows by extensionality.
%Symmetry follows straightforwardly from symmetry of $(\sim)$ and $(\approx)$.
%
%Now we show transitivity.
%Assume that $d_1 \equiv d_2$ and $d_2 \equiv d_3$.
%We have to show that $d_1 \equiv d_3$.
%
%For that we assume $A ⊦ μ_1 \approx μ_3$ for some $A,μ_1,μ_3$ such that
%$\adom(d_1) ⊆ A, \adom(d_3) ⊆ A$, fix some $μ'$ and have to show that
%\[
%  A ∪ \dom(μ') ⊦ d_1(μ_1 \oplus μ') \sim d_3(μ_3 \oplus μ').
%\]
%% TODO
%W.l.o.g., we assume that $\adom(d_2) ⊆ A$.
%Otherwise, we construct extended heaps $μ_1' \triangleq μ_1 \oplus μ'',μ_3' \triangleq μ_3 \oplus μ''$
%such that $\adom(d_2) ⊆ A ∪ \dom(μ')$,
%for which we have $μ_1 \forcesto μ_1'$, $μ_3 \forcesto μ_3'$ and
%$A ∪ \dom(μ') ⊦ μ_1' \approx μ_3'$ (by \Cref{thm:memo-approx-extend} applied
%to $A ⊦ μ_1 \approx μ_3$).
%The goal follows by \Cref{thm:lazy-force-bisimilar} applied to the two forcing
%relationships, transitivity of $(\sim)$ and \Cref{thm:weaken-address-space}.
%
%Clearly, $A ⊦ μ_1 \approx μ_1$ by reflexivity, so we can invoke
%$d_1 \equiv d_2$ (recalling that $\adom(d_2) ⊆ A$) to have
%\[
%  A ⊦ d_1(μ_1) \sim d_2(μ_1).
%\]
%We invoke $d_2 \equiv d_3$ on $A ⊦ μ_1 \approx μ_3$ to get
%\[
%  A ⊦ d_2(μ_1) \sim d_3(μ_3)
%\]
%and by transitivity we show the goal.
%\end{proof}
%
%What remains is a proof that $\semevt{\pe}_ρ$ is indeed extensional.
%
%\begin{theorem}
%  \label{thm:semevt-ext}
%  For all environments $ρ$ and expressions $\pe$,
%  $\semevt{\pe}_ρ$ is extensional.
%\end{theorem}
%\begin{proof}
%By induction on $\pe$.
%In each case, we assume a fixed $A,μ_1,μ_2$ such that $\adom(\semevt{\pe}_ρ) ⊆ A$, $A ⊦ μ_1 \approx μ_2$ and fix $μ'$ to show
%\[
%  A ∪ \dom(μ') ⊦ \semevt{\pe}_ρ(μ_1 \oplus μ') \sim \semevt{\pe}_ρ(μ_2 \oplus μ')
%\]
%We also have $A ∪ \dom(μ') ⊦ μ_1 \oplus μ' \approx μ_2 \oplus μ'$ by applying
%\Cref{thm:memo-approx-extend} to $A ⊦ μ_1 \approx μ_2$.
%\begin{itemize}
%  \item \textbf{Case $\px$}:
%    $\fn{\wild}{\stuckend{}}$ is extensional in case $\px \not∈ \dom(ρ)$.
%
%    Otherwise, $ρ(\px) = \pa ∈ A$.
%    Then the goal is to show that
%    \[
%      \later (A ∪ \dom(μ') ⊦ μ_1(\pa)(μ_1 \oplus μ') \sim μ_2(\pa)(μ_2 \oplus μ'))
%    \]
%    in order to apply $\eqlrcons$ and that follows simply by $A ⊦ μ_1 \approx μ_2$.
%
%  \item \textbf{Case $\Lam{\px}{\pe'}$}:
%    The goal is to show
%    \[
%      A ∪ \dom(μ') ⊦ \goodend{v,μ_1 \oplus μ'} \sim \goodend{v,μ_2 \oplus μ'}
%    \]
%    where $v \triangleq \FunV(\fn{\pa}{\AppEE(\px↦\pa) \cons \semevt{\pe'}_{ρ[\px↦\pa]}})$.
%    So let us fix $\pa ∈ A ∪ \dom(μ')$ and show
%    \[
%      A ∪ \dom(μ') ⊦ \semevt{\pe'}_{ρ[\px↦\pa]}(μ_1 \oplus μ') \sim \semevt{\pe'}_{ρ[\px↦\pa]}(μ_2 \oplus μ').
%    \]
%    We can apply $A ∪ \dom(μ') ⊦ μ_1 \oplus μ' \approx μ_2 \oplus μ'$ to the
%    induction hypothesis for $\semevt{\pe'}_{ρ[\px↦\pa]}$ to show the goal.
%
%  \item \textbf{Case $K~\many{\px}$}:
%    Similar to the lambda case, exploiting $A ∪ \dom(μ') ⊦ μ_1 \oplus μ' \approx μ_2 \oplus μ'$ for the field addresses.
%
%  \item \textbf{Case $\pe'~\px$}:
%    $\fn{\wild}{\stuckend{}}$ is extensional in case $\px \not∈ \dom(ρ)$.
%
%    Otherwise, by induction it suffices to show that for extensional
%    $d \triangleq \semevt{\pe'}_ρ$, the $\apply$ expression
%    $d \betastep \fn{(\FunV(f))}{f(ρ(\px))}$ is extensional.
%
%    The interesting case is when $\bigstep{d}{μ_i \oplus μ'}{\FunV(f_i)}{μ'_i}$.
%    We have to show that $A ∪ \dom(μ') ⊦ f_1(ρ(\px))(μ_1') \sim f_2(ρ(\px))(μ_2')$,
%    the rest follows by congruence.
%    From extensionality of $d$ (which is the result of applying the inductive hypothesis),
%    we know by $\eqfun$ that $A ∪ \dom(μ') ⊦ f_1(\pa)(μ_1') \sim f_2(\pa)(μ_2')$
%    for any $\pa$ such that $\pa ∈ A ∪ \dom(μ')$.
%    Since $ρ(\px) ∈ A$ by the Address Domain property, we can show the goal.
%
%  \item \textbf{Case $\Case{\pe_s}{\Sel[r]}$}:
%    Similar to the application case.
%
%  \item \textbf{Case $\Let{\px}{\pe_1}{\pe_2}$}:
%    Let $\pa \not∈ \dom(μ_i)$ and
%    abbreviate
%    $ρ' \triangleq ρ[\px↦\pa]$,
%    $d \triangleq \semevt{\pe_1}_{ρ'}$,
%    $μ_i' \triangleq μ_i[\pa ↦ \memo(\pa,d)]$.
%
%    For extensionality of $\semevt{\Let{\px}{\pe_1}{\pe_2}}_ρ$, we have to show
%    \[
%       A ∪ \dom(μ') ⊦ \semevt{\pe_2}_{ρ'}(μ_1' \oplus μ') \sim \semevt{\pe_2}_{ρ'}(μ_2' \oplus μ')
%    \]
%
%    Since $d$ is extensional by the inductive hypothesis,
%    we have $A ∪ \{\pa\} ⊦ μ_1' \approx μ_2'$ by \Cref{thm:memo-approx-extend}.
%    We apply the inductive hypothesis once more to have
%    extensionality of $\semevt{\pe_2}_{ρ'}$.
%    Applying that to $A ∪ \{\pa\} ⊦ μ_1' \approx μ_2'$, we have
%    \[
%       A ∪ \{\pa\} ∪ \dom(μ') ⊦ \semevt{\pe_2}_{ρ'}(μ_1' \oplus μ') \sim \semevt{\pe_2}_{ρ'}(μ_2' \oplus μ')
%    \]
%    and we can weaken the address space to $A ∪ \dom(μ')$ by
%    \Cref{thm:weaken-address-space} to show the goal.
%\end{itemize}
%\end{proof}
%
%As before, we will assume that all elements $d$ are lazy and extensional from
%now on.
%
%\subsection{Compositionality}
%
%Compositionality is an important property of a semantics (or, rather of a
%congruence relation on the semantics).
%Roughly, when a semantics is compositional, the denotation of an expression
%is a function of the meaning of its subexpressions.
%The ``is a function of'' qualifier is most often understood syntactically
%in terms of a property of \emph{contexts}.
%
%We follow \citet{MoranSands:99} and define \emph{evaluation contexts} $\pE$%
%\footnote{In \Cref{defn:deadness2} we already used the term ``evaluation
%context'' to denote small-step machine components $(ρ,μ,κ)$ rather than
%$\pE$. \citet{MoranSands:99} prove that both notions are equivalent, so this
%overload is justified.}
%with holes $\hole$ in order to formalise compositionality.
%Then $\pE[\pe]$ denotes an expression where the hole in $\pE$ has been replaced
%with $\pe$, expressing that the bigger expression $\pE[\pe]$ is a (linear)
%function of $\pe$.
%\[\begin{array}{rcl}
%  \pE & ::=  & \hole \mid \pE~\px \mid \Let{\px}{\pe}{\pE} \mid \Let{\px}{\pE_1}{\pE_2[\px]} \mid \Case{\pE}{\Sel[r]} \\
%\end{array}\]
%
%\begin{definition}[Compositionality of an equivalence relation]
%  Let $\cong$ be an equivalence relation on expressions.
%  $\cong$ is \emph{compositional} if and only if for all $\pe_1,\pe_2$,
%  $\pe_1 \cong \pe_2$ implies $\pE[\pe_1] \cong \pE[\pe_2]$ for all evaluation
%  contexts $\pE$.
%\end{definition}
%
%It is well-known that \emph{contextual equivalence} is compositional:
%
%\begin{definition}[Contextual equivalence, as in \citep{MoranSands:99}]
%  Two expressions $\pe_1,\pe_2$ are \emph{contextually equivalent}, written
%  $\pe_1 \equiv_{\mathit{ctx}} \pe_2$, if their termination behavior coincides
%  in all contexts, \eg, for all closed evaluation contexts $\pE$ it is
%  \[
%    \len(\semevt{\pE[\pe_1]}_{[]}([])) = ω \Longleftrightarrow \len(\semevt{\pE[\pe_2]}_{[]}([])) = ω
%  \]
%  where $\len$ is the length function from \Cref{defn:length}.
%\end{definition}
%
%The definition of \citet{MoranSands:99} is in terms of a transition system like
%$(\smallstep)$, but adequacy (\Cref{thm:semvan-adequate}) guarantees that the two
%notions coincide.
%
%\begin{lemma}[Contextual equivalence is compositional]
%  Let $\pe_1, \pe_2$ be expressions such that
%  $\pe_1 \equiv_{\mathit{ctx}} \pe_2$.
%  Then for all evaluation contexts $\pE$, we have
%  $\pE[\pe_1] \equiv_{\mathit{ctx}} \pE[\pe_2]$.
%\end{lemma}
%\begin{proof}
%  Immediate, because $\pE[\pE_2[\hole]]$ is just another context in which
%  contextually equivalent expressions are contextually equivalent.
%\end{proof}
%
%$\semevt{\wild}$ is compositional \wrt definitional equality $=$ on
%$\EventD$:
%
%\begin{lemma}[Definitional equivalence is compositional]
%  Let $\pe_1, \pe_2$ be expressions such that
%  for all environments $ρ$, $\semevt{\pe_1}_ρ = \semevt{\pe_2}_ρ$.
%  Then for all evaluation contexts $\pE$ and environments $ρ$, we have
%  $\semevt{\pE[\pe_1]}_{ρ} = \semevt{\pE[\pe_2]}_{ρ}$.
%\end{lemma}
%\begin{proof}
%  By induction on $\pE$, similar but simpler than \Cref{thm:sem-equiv-comp}.
%\end{proof}
%
%Most interestingly, $\semevt{\wild}$ is also compositional \wrt to $(\equiv)$!
%
%\begin{theorem}[Semantic equivalence is compositional]
%  \label{thm:sem-equiv-comp}
%  Let $\pe_1, \pe_2$ be expressions such that
%  for all environments $ρ$, $\semevt{\pe_1}_ρ \equiv \semevt{\pe_2}_ρ$.
%  Then for all evaluation contexts $\pE$ and environments $ρ$, we have
%  $\semevt{\pE[\pe_1]}_{ρ} \equiv \semevt{\pE[\pe_2]}_{ρ}$.
%\end{theorem}
%\begin{proof}
%  By induction on $\pE$.
%  In each case, we assume a fixed $A,μ_1,μ_2$ such that $\adom(\semevt{\pe}_ρ) ⊆ A$, $A ⊦ μ_1 \approx μ_2$ and fix $μ'$ to show
%  \[
%    A ∪ \dom(μ') ⊦ \semevt{\pE[\pe_1]}_ρ(μ_1 \oplus μ') \sim \semevt{\pE[\pe_2]}_ρ(μ_2 \oplus μ')
%  \]
%  We also have $A ∪ \dom(μ') ⊦ μ_1 \oplus μ' \approx μ_2 \oplus μ'$ by applying
%  \Cref{thm:memo-approx-extend} to $A ⊦ μ_1 \approx μ_2$.
%  \begin{itemize}
%    \item \textbf{Case $\hole$}: By assumption, $\semevt{\pe_1}_ρ \equiv \semevt{\pe_2}_ρ$.
%
%    \item \textbf{Case $\pE~\px$}:
%      It is $\fn{\wild}{\stuckend{}} \equiv \fn{\wild}{\stuckend{}}$ in case $\px \not∈ \dom(ρ)$.
%
%      Otherwise, by induction it suffices to show that for $d_1 \equiv d_2$
%      (where $d_i \triangleq \semevt{\pE[\pe_i]}_ρ$), we have
%      \[
%        d_1 \betastep \fn{(\FunV(f))}{f(ρ(\px))} \equiv d_2 \betastep \fn{(\FunV(f))}{f(ρ(\px))}.
%      \]
%      The interesting case is when
%      $\bigstep{d_i}{μ_i \oplus μ'}{\FunV(f_i)}{μ'_i}$.
%      We have to show that $A ∪ \dom(μ') ⊦ f_1(ρ(\px))(μ_1') \sim f_2(ρ(\px))(μ_2')$, the
%      rest follows by congruence.
%      From $d_1 \equiv d_2$, we know that $A ∪ \dom(μ') ⊦ f_1(\pa)(μ_1') \sim f_2(\pa)(μ_2')$ for any $\pa ∈ \dom(μ_1)$.
%      Since $ρ(\px) ∈ A$ by the Address Domain property we can show the goal.
%
%    \item \textbf{Case $\Case{\pE}{\Sel[r]}$}:
%      Similar to the application case.
%
%    \item \textbf{Case $\Let{\px}{\pe}{\pE}$}:
%      Note that the equivalence $A ⊦ μ_1 \approx μ_2$ can be extended to
%      $A ∪ \{\pa\} ⊦ μ_1[\pa ↦ \memo(\pa,d)] \approx μ_2[\pa ↦ \memo(\pa,d)]$ for any
%      extensional $d$ by \Cref{thm:memo-approx-equiv}, and for $d \triangleq
%      \semevt{\pe}_{ρ'}$ in particular.
%      Then the goal follows by the inductive hypothesis applied to
%      $\semevt{\pE[\pe_1]}_{ρ'} \equiv \semevt{\pE[\pe_2]}_{ρ'}$
%      and \Cref{thm:weaken-address-space}.
%
%    \item \textbf{Case $\Let{\px}{\pE_1}{\pE_2[\px]}$}:
%      Abbreviating $d_{\pe_i} \triangleq \semevt{\pE_1[\pe_i]}_{ρ'}$, the
%      induction hypothesis gives us $d_{\pe_1} \equiv d_{\pe_2}$,
%      so $A ∪ \{\pa\} ⊦ μ_1[\pa ↦ \memo(\pa,d_{\pe_1})] \approx μ_2[\pa ↦ \memo(\pa, d_{\pe_2})]$
%      by \Cref{thm:memo-approx-equiv}, and we have
%      \[
%        A ∪ \{\pa\} ∪ \dom(μ') ⊦ \semevt{\pE_2[\px]}_{ρ'}((μ_1 \oplus μ')[\pa ↦ d_{\pe_1}]) \sim \semevt{\pE_2[\px]}_{ρ'}((μ_2 \oplus μ')[\pa ↦ d_{\pe_2}])
%      \]
%      by extensionality of $\semevt{\pE_2[\px]}_{ρ'}$, which we can weaken to
%      show the goal.
%  \end{itemize}
%\end{proof}
%
%And finally, we can use this result to prove that $(\equiv)$ is indeed coarser than contextual equivalence:
%
%\begin{corollary}[Semantic equivalence implies contextual equivalence]
%  \label{thm:sem-equiv-cont-equiv}
%  Let $\pe_1, \pe_2$ be expressions such that $\semevt{\pe_1}_ρ \equiv \semevt{\pe_2}_ρ$.
%  Then for all closed evaluation contexts $\pE$, we have
%  \[
%    \len(\semevt{\pE[\pe_1]}_{[]}([])) = ω \Longleftrightarrow \len(\semevt{\pE[\pe_1]}_{[]}([])) = ω.
%  \]
%\end{corollary}
%\begin{proof}
%  It suffices to show that for all $d_1,d_2$ with $\varnothing ⊦ d_1,d_2$,
%  if $d_1 \equiv d_2$ then $\len(d_1([])) = ω \Longleftrightarrow \len(d_2([])) = ω$.
%
%  Since $[] \approx []$, we have $\varnothing ⊦ d_1([]) \sim d_2([])$.
%  Then either trace diverges if and only if the other does, if and only if the
%  length of the trace is $ω$.
%\end{proof}
%
%This corollary naturally leads to the converse question:
%Does contextual equivalence imply semantic equivalence?
%If that were the case, then $\semevt{\wild}$ would be \emph{fully abstract} via
%$(\equiv)$~\citep{Plotkin:77}.
%\citeauthor{Plotkin:77} established that a definition like $\semscott{\wild}$ is
%not fully abstract via definitional equality on $\ScottD$.
%Guarded types prevent probing for diverging computations without executing them,
%but it is still possible for lazy elements to probe traces for stuckness without
%propagating it or evaluating multiple traces concurrently, so we have reason to
%doubt that $\semevt{\wild}$ is fully abstract.
%\end{toappendix}
