\section{Stateless Semantics}
\label{sec:stateless}

In the previous section, we gave a compositional trace-based semantics and
proved it adequate \wrt the LK transition semantics.
With compositionality and structural induction we recover strong advantages of
denotational semantics.

It is striking that although $\semst{\wild}$ is as expressive as the LK
transition system, the information encoded in the states of the generated traces
is not enough to recover the LK transition system in the sense of
\citet[Chapter 43]{Cousot:21}.
For example, every return state $((\lbl,v),\tm)$ admits at least two possible
transitions:
Either a heap update or a $β$-reduction.
In the LK transition system, the particular transition is governed by the
continuation stack, of which $\semst{\wild}$ maintains no reification in its states.
It is however trivial to ``elaborate'' $\semst{\wild}$ to include the proper
stack manipulations and emit the current lexical environment as part of every
state.
We think it is rather uninteresting to give the closed, elaborated definition
of $\semst{\wild}$ which necessarily gives up simplicity.
It is more interesting to see what other parts of the traces we can \emph{omit}
before compromising on expressivity.

For example, in Control-Flow Analysis~\citep{Shivers:91}, we are interested in
observing in each state of a trace the label of the expression in control.
That makes $\semst{\wild}$ a suitable semantics for abstraction.
Yet for our usage analysis in \Cref{sec:problem}, we do not care so much
about the \emph{state} in which variable lookup happens, but rather about at
which \emph{address} the $\LookupT$ transition happened, as well as the $\BindT$
transition that tells us what $\mathbf{let}$ binding that particular address
refers to.

In this section, we will omit states --- including the explicitly maintained
heap --- altogether in favor of tracing the instantiations of transition rules,
called \emph{actions}.
The resulting \emph{stateless trace semantics} $\semless{\wild}$ is the
preferred framework of \citet{Cousot:21}, in which the heap will be
rematerialised as needed from the history of previous actions.

\begin{figure}
\[\begin{array}{c}
 \arraycolsep=3pt
 \begin{array}{rrclcl}
  \text{Actions} & a & ∈ & \Actions & ::=  & \AppIA(d) \mid \AppEA(\px↦d) \mid \BindA(\px,\pa↦d^{\later}) \mid \LookupA(\pa) \mid \UpdateA(\pa) \\
                 &   &   &          & \mid & \CaseIA(d) \mid \CaseEA(K,\many{\px↦d}) \mid \ValueA(v) \\
 \end{array} \\
 \arraycolsep=3pt
 \begin{array}{rrclcl@{\quad}rrclcl}
  \text{Initialisation Traces} & τ^i        & ∈ & \Traces^*               & ::= & [a_1,...,a_n], n ∈ ℕ_0
  &
  \text{Stateless domain}      & d          & ∈ & \MaxD                   & =   & \Traces^* \to \Traces^{\infty}
  \\
  \text{Program Traces}        & τ          & ∈ & \Traces^{\infty}        & ::= & \goodend{a} \mid \stuckend{} \mid a \cons τ^{\later}
  &
  \text{Delayed Trace}         & τ^{\later} & ∈ & \later \Traces^{\infty} &     &   \\
 \end{array} \\
 \arraycolsep=3pt
 \begin{array}{rrclcl}
  \text{Stateless values} & v & ∈ & \Values{} & ::= & \FunV(f ∈ \MaxD \to \later \MaxD) \mid \ConV(K,\many{d^{\later}}^{α_K}) \\
 \end{array} \\
 \\[-0.5em]
 \ruleform{ (\concat) : \Traces^{\infty} \to \later\Traces^{\infty} \to \Traces^{\infty} \quad (\fcomp) : \MaxD \to \later\MaxD \to \MaxD \quad \tell{\wild} : \Actions \to \MaxD} \\
 \\[-0.5em]
 \begin{array}{cc}
  \begin{array}{rcl}
   τ_1 \concat τ_2^{\later} & = & \begin{cases}
     a \cons \idiom{τ_1^{\later} \concat τ_2^{\later}} & τ_1 = a \cons τ_1^{\later} \\
     a \cons τ_2^{\later} & τ_1 = \goodend{a} \\
     \stuckend{} & τ_1 = \stuckend{} \\
   \end{cases} \\
  \end{array} &
  \begin{array}{rcl}
   \\[-0.5em]
   (d_1 \fcomp d_2^{\later})(τ^i)   & = & d_1(τ^i) \concat \idiom{d_2^{\later}(τ^i \concat d_1(τ^i))} \\
   \\[-0.5em]
   \tell{a}(τ^i) & = & \goodend{a} \\
  \end{array} \\
 \end{array} \\
 \\[-0.5em]
 \begin{array}{rcl}
  \multicolumn{3}{c}{ \ruleform{
    \begin{array}{c}
      β : (\Values{} \pfun \later\MaxD) \to \later\MaxD \quad μ : \Traces^{+} \to \Addresses \pfun \later\MaxD \\
      \deref : \Addresses \to \MaxD \quad \apply : \MaxD \to \later\MaxD \\
      \select : ((\MaxD)^{α_K} \pfun \MaxD)^* \to \later\MaxD \\
    \end{array}
  }} \\
  \\[-0.5em]
  β(f)(τ^i) & = & \begin{cases}
      \idiom{f(v)(τ^i)} & \text{$τ^i = [..., \ValueA(v), \many{\UpdateA(\wild)}]$ and $v ∈ \dom(f)$} \\
      \idiom{\stuckend{}} & \text{otherwise} \\
    \end{cases} \\
  \\[-0.5em]
  μ(τ^i)(\pa) & = & \begin{cases}
    \tell{\ValueA(v)} & \text{if $τ^i = [..., \ValueA(v), \many{\UpdateA(\wild),}\, \UpdateA(\pa),...]$} \\
    d & \text{if $τ^i = [..., \BindA(\px,\pa↦d), ...]$} \\
  \end{cases}  \\
  \\[-0.5em]
  \deref(\pa)(τ^i)   & = & (\tell{\LookupA(\pa)} \fcomp μ(τ^i)(\pa) \fcomp \tell{\UpdateA(\pa)})(τ^i) \\
  \apply(d_\px) & = & β(\fn{(\FunV(f))}{\idiom{f(d_\px)}}) \\
  \select(\many{f}) & = & β(\fn{(\ConV(K_s,\many{d_s}))}{\idiom{f_s(\many{d_s})}}) \\
 \end{array} \\
 \\[-0.5em]
 \begin{array}{rcl}
  \multicolumn{3}{c}{ \ruleform{ \semless{\wild} \colon \Exp → (\Var \pfun \MaxD) → \MaxD } } \\
  \\[-0.5em]
  \semless{\px}_ρ       & = & \begin{cases}
    ρ(\px) & \px ∈ \dom(ρ) \\
    \fn{\wild}{\stuckend{}}  & \text{otherwise} \\
  \end{cases} \\
  \\[-0.5em]
  \semless{\Lam{\px}{\pe}}_ρ & = & \tell{\ValueA(\FunV(\fn{d}{\tell{\AppEA(\px↦d)} \fcomp \semless{\pe}_{ρ[\px↦d]}}))} \\
  \\[-0.5em]
  \semless{\pe~\px}_ρ   & = & \begin{cases}
    \tell{\AppIA(ρ(x))} \fcomp \semless{\pe}_ρ \fcomp \apply(ρ(\px)) & \px ∈ \dom(ρ) \\
    \fn{\wild}{\stuckend{}}  & \text{otherwise} \\
  \end{cases} \\
  \\[-0.5em]
  \semless{\Let{\px}{\pe_1}{\pe_2}}_ρ(τ^i) & = &
    \begin{letarray}
      \text{let} & ρ' = ρ[\px ↦ \deref(\pa)] \quad \text{where $\pa \not∈ \dom(μ(τ^i))$} \\
      \text{in}  & (\tell{\BindA(\px,\pa↦\semless{\pe_1}_{ρ'})} \fcomp \semless{\pe_2}_{ρ'})(τ^i)
    \end{letarray} \\
  \\[-0.5em]
  \semless{K~\many{\px}}_ρ & = & \tell{\ValueA(\ConV(K,\many{\semless{\px}_ρ}))} \\
  \\[-0.5em]
  \semless{\Case{\pe_s}{\Sel[r]}}_ρ & = &
    \begin{letarray}
      \text{let} & \many{f_K = \fn{\many{d}^{α_K}}{\tell{\CaseEA(K,\many{\px↦d})} \fcomp \semless{\pe_r}_{ρ[\many{\px↦d}]}}} \\
      \text{in} & \tell{\CaseIA(\semless{\pe_s}_ρ)} \fcomp \semless{\pe_s}_ρ \fcomp \select(\many{f})  \\
    \end{letarray}
 \end{array} \\
\end{array}\]
\caption{Stateless Trace Semantics}
  \label{fig:semless}
\end{figure}

\subsection{Going stateless}

\Cref{fig:stateless-syntax} provides the new syntactic building blocks of the
semantics. A \emph{program point} $\pc$ is either a return point $\return$ or a
labelled expression; each program point defines one of finitely many
control-flow nodes of the program. Actions $a$ correspond one-to-one to the
transition rules of the LK machine, only they are now retained in an AST-like
fashion in the trace instead of eliminated (via functions $app_1$, $app_2$,
$bind$, \etc) to produce the successor state. Stateless traces $τ$ carry the
the transition taken as an action $a$. We re-use the same greek letter as in
\Cref{sec:stateful} and disambiguate as needed. We consider inductively-defined
finite traces $τ^+$ a subtype of the potentially infinite and thus
coinductively-defined traces $τ$.

Comparing the domain of maximal traces with the one for LK traces from
\Cref{fig:lk-domain}, we can see that a finite \emph{initialisation trace} takes
the place of the initial state as a parameter to a domain element $d$.
Similarly, the use of $\Addresses$ in the definition of semantic values $v$ is
replaced in favor of a seemingly more complex argument of type $\MaxD$; in
practice the $d$ passed will be one-to-one to the address passed in the stateful
semantics.

% Note [Design of Maximal Trace Semantics]
% ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
% A stateless (prefix) trace semantics' defining feature is the absence of
% full-blown configurations between actions. However, states can be
% reconstructed from looking at the history of actions in the initialisation
% trace. So it is quite vital that the actions carry enough information.
%
% The need for a value action
% ---------------------------
% Values have after labels, so that when we reach at(v) we make one value
% transition to announce the value of at(v) in the trace. Without this
% action, it would be hard to differentiate between stuck and successful
% maximal traces. Furthermore, it plays a crucial role in the memoisation
% mechanism, where we reconstruct the memoised value from the trace.
%
% A different design would be to have controls `expr | (lbl, sem value)`,
% but then we still need the value transition: Otherwise, callers of
% S[λx.e] must supply the semantic value of the lambda at the end of the
% initialisation trace which defeats the point.
%
% The need for an update action
% -----------------------------
% Memoisation could well work by looking for a balanced sub-trace in the
% initialisation trace that started with look(τ_k). In fact, earlier
% versions did exactly that, and it worked great!
% Unfortunately, it has the following drawbacks:
%   * CESK semantics does have update frames and we want to match those
%     rather simply. It is a matter of producing "complete" states, see
%     "Which info do we need to attach to an action?"
%   * We need to define relatively early what a balanced trace is.
%     The semantics itself should not depend on that...
%   * It is simpler to define the abstraction to stateful prefix trace semantics
%     when there are corresponding update actions
%   * It is better to be explicit to announce exactly when "the heap binding
%     changes" for the perspective of weak memory models and interleavings of
%     parallel traces (TODO: Read up on that!), which is one of the prime
%     reasons to consider stateless trace semantics in the first place.
%
% Why is the stateless semantics not simply (V, T+ -> T+∞)?
% ---------------------------------------------------------
% ... and in the process could abandon the value action (if we were willing
% to detect stuckness by looking at V)?
%
% Because then we can't see the prefix T+ when we have to extend ρ at let
% bindings. But this is our primary mechanism for sharing! Similarly for
% call-by-value.
%
% So we are stuck with value actions. Still, we could decide to return the
% value "out of band", in a pair, T+ -> (V, T+∞). That yields the worse of
% both worlds; the definition is similar to T+ -> T+∞ but we often need to
% adjust the second component of the pair; plus, in `memo`, we still have
% to "execute" the semantics S for its value, because we can't recover it
% from the trace.
%
% Which info do we need to attach to an action?
% ---------------------------------------------
% TLDR; that is determined by transition semantics that we want to
% be to abstract a trace into. The reasoning is as follows:
%
%   * "The transition semantics" is really the semantics we get by
%     applying the transition abstraction α_τ to a *stateful* trace
%     semantics, where the states capture enough information for
%     the resulting transition system to become deterministic.
%     (The transition system we get by abstracting the *stateless* trace
%     semantics isn't very useful precisely for that reason; taking
%     labels as state yields too many spurious transitions.)
%   * So determinism of the abstracted transition system is a quality
%     of the semantic richness of states (given that the sequence of states
%     is fixed); let's call state structure that allows for deterministic
%     abstraction "complete"
%   * (Are all complete state structures isomorph? Probably not)
%   * The stateful trace semantics is an abstraction of the stateless trace
%     semantics by way of α_S. We want to produce (at least one) stateful
%     semantics where the state space is complete. To produce such states, the
%     necessary information must be part of the stateless trace, otherwise we
%     can't write the abstraction function from stateless to stateful.
%
% So given the completeness of the states produced by α_S as a goal, we can
% make the following claims for action kinds in a trace:
%
%   * AppI, AppE, Lookup, Bind are all necessary actions because they make
%     a step from one label to a label of a subexpression.
%   * Val actions are the trace semantics' means of communicating a successful
%     (e.g., not stuck) execution as well as playing the role of `Just value`.
%     They correspond to Val transtitions in CESK or STG's ReturnCon
%   * We do *not* strictly need Update actions -- we just need update frames
%     in the stateful trace, but those could be reconstructed from when a
%     Lookup's balanced trace ended. Update actions make our life simpler in
%     other ways, though: See "The need for an update action".
%
% In fact, given that each action corresponds to a CESK transition, α_S can be
% defined inductively (by prefixes) on actions and states:
%
%   * The data on actions is simply erased and the corresopnding CESK transition
%     is taken. (Vital to realise that a well-formed stateless trace results in
%     an ok stateful trace.)
%   * For the state after prefix τ, we simply call \varrho(τ). It is a function
%     that Cousot uses throughout his book, and so should we.
%
% Now as to what information we need on the actions:
%
%   * AppI: We need the Var so that α_S can produce an Apply frame
%   * AppE: We need both the Var *and* the D so that varrho can produce the
%           proper environment.
%   * Lookup: We need the address so that we can push an update frame in α_S.
%             Also we need it to find the corresponding Bind.
%   * Bind: We need the address, so α_S can find it when encountering a Lookup
%           at that address. Then we also need the Var and the D for varrho.
%   * Update: The address is convenient (as are update actions to begin with),
%             otherwise we'd have to fiddle with balanced traces in memo to find
%             the corresponding Lookup.
%   * Values: It is convenient to attach values to Val actions; this is not strictly
%     necessary, just convenient. (See page 4 of 61e6f8a, quite ugly.)

\subsection{Abstraction}

% 1. Move Lookup into Env; have Env = Name :-> D and let its action look into
%    the Heap. Requires a bit of tricky setup in let_
% 2. Move the Env to meta level
% 3. Realise that we can now get rid of the stack, since everything happens
%    on the meta call stack
% 4. Materialise the state as needed during memo

\begin{figure}
\[\begin{array}{rcl}
  μ_ρ(τ)(\pa) & = & \begin{cases}
    \varrho(τ_1) & \text{if $τ_1 \act{\UpdateA(\pa)} \return \concat τ_2 = τ$} \\
    \varrho(τ_1 \act{\BindA(\px,\pa↦\pe,d)} \pc) & \text{if $τ_1 \act{\BindA(\px,\pa↦\pe,d)} \pc \concat τ_2 = τ$} \\
  \end{cases}  \\
  \varrho(τ \act{\BindA(\px,\pa↦\pe,d)} \pc\trend)(\px) & = & deref(\pa) \\
  \varrho(τ \act{\AppEA(\px↦d)} \pc\trend)(\px) & = & d \\
  \varrho(τ \act{\LookupA(\pa)} \pc\trend)(\px) & = & μ_ρ(τ)(\pa)(\px) \\
  \varrho(τ \act{a} \pc\trend)(\px) & = & \varrho(τ)(\px) \\
\end{array}\]
\caption{Materialising heap and environment from an initialisation trace}
  \label{fig:materialisation}
\end{figure}

\begin{figure}
\[\begin{array}{c}
 \begin{array}{rcl}
  \multicolumn{3}{c}{ \ruleform{ α^{\States} : ((\Var \pfun \MaxD) \to \MaxD) \to \StateD } } \\
  \\[-0.5em]
  deref^{-1}(d) & = & \pa \text{ such that $d = deref(\pa)$} \\
  tgt_\States^{-1}(σ) & = & τ \text{ such that $\validtrace{τ}$ and $tgt_\States(τ) = σ$} \\
  \\[-0.5em]
  α_{\STraces}(τ^i, \pc\trend) & = & α_{\States}(τ^i \concat \pc\trend)\trend \\
  α_{\STraces}(τ^i, τ \act{a} \pc\trend) & = & α_{\STraces}(τ^i,τ); α_{\States}(τ^i \concat τ \act{a} \pc\trend)\trend \\
  α_{\States}(τ) & = & (α_{\Controls}(τ,tgt(τ)), α_{\Environments}(\varrho(τ)), α_{\Heaps}(τ) \circ μ(τ), α_{\Continuations}(τ)) \\
  α_{\Controls}(τ, \return) & = & (\pv,α_{\StateV}(v)) \text{ where $\getval{τ}{(\pv,v)}$} \\
  α_{\Controls}(τ, \pe) & = & \pe \\
  α_{\Environments}(ρ) & = & deref^{-1} \circ ρ \\
  α_{\Heaps}(τ)([\many{\pa ↦ (\pe,d)}]) & = & [\many{\pa ↦ (\pe, μ_ρ(τ)(\pa), α_{\StateD}(d))}] \\
  α_{\Continuations}(\pc\trend) & = & \StopF \\
  α_{\Continuations}(τ \act{\LookupA(\pa)} \pc\trend) & = & \UpdateF(\pa) \pushF α_{\Continuations}(τ) \\
  α_{\Continuations}(τ \act{\UpdateA(\pa)} \pc\trend) & = & κ \text{ where $α_{\Continuations}(τ) = \UpdateF(\pa) \pushF κ$} \\
  α_{\Continuations}(τ \act{\AppIA(d)} \pc\trend) & = & \ApplyF(deref^{-1}(d)) \pushF α_{\Continuations}(τ) \\
  α_{\Continuations}(τ \act{\AppEA(\px↦d)}   \pc\trend) & = & κ \text{ where $α_{\Continuations}(τ) = \ApplyF(deref^{-1}(d)) \pushF κ$} \\
  α_{\Continuations}(τ \act{} \pc\trend) & = & α_{\Continuations}(τ) \\
  α_{\StateD}(d) & = & (\fn{τ}{α_{\STraces}(τ,d(τ))) \circ γ_{\STraces} \circ tgt_\States^{-1}} \\
  α_{\StateV}(\FunV(f)) & = & \FunV(α_{\StateD} \circ f \circ deref) \\
  γ_{\StateD}(d) & = & γ_{\STraces} \circ d \circ tgt_\States \circ α_{\STraces} \\
  γ_{\StateV}(\FunV(f)) & = & \FunV(γ_{\StateD} \circ f \circ deref^{-1}) \\
  γ_{\STraces}(σ\trend) & = & γ_{\States}(σ)\trend \\
  γ_{\STraces}(τ; σ\trend) & = & γ_{\STraces}(τ) \act{γ_{\Actions}(tgt_\States(τ) \smallstep σ)} γ_{\States}(τ; σ\trend)\trend \\
  γ_{\States}(γ,\wild,\wild,\wild) & = & α_{\Controls}(γ) \\
  γ_{\Controls}((\pv,v)) & = & \return \\
  γ_{\Controls}(\pe) & = & \pe \\
  γ_{\Actions}(\BindT(\px,\pa,\pe_1,d)) & = & \BindA(\px,\pa↦\pe_1,γ_{\StateD}(d)) \\
  γ_{\Actions}(\UpdateT(\pa)) & = & \UpdateA(\pa) \\
  γ_{\Actions}(\LookupT(\pa)) & = & \LookupA(\pa) \\
  γ_{\Actions}(\AppIT(\pa)) & = & \AppIA(deref(\pa)) \\
  γ_{\Actions}(\AppET(\px,\pa)) & = & \AppEA(\px,deref(\pa)) \\
  γ_{\Actions}(\ValueT(\pv,v)) & = & \ValueA(\pv,γ_{\StateV}(v)) \\
  \\
 \end{array}
\end{array}\]
\caption{Prefix Trace Abstraction}
  \label{fig:semantics}
\end{figure}
