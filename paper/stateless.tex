\section{Stateless Semantics}
\label{sec:stateless}

In the previous section, we gave a trace semantics and proved it adequate \wrt
the LK transition semantics.
With compositionality and structural induction we recover strong advantages of
denotational semantics.

It is striking that although $\semst{\wild}$ is as expressive as the LK
transition system, the information encoded in the states of the generated traces
is not enough to recover the LK transition system in the sense of
\citet[Chapter 43]{Cousot:21}.
For example, every return state $((\lbl,v),\tm)$ admits at least two possible
transitions:
Either a heap update or a $β$-reduction.
In the LK transition system, the particular transition is governed by the
continuation stack, of which $\semst{\wild}$ maintains no reification in its states.
It is however trivial to ``elaborate'' $\semst{\wild}$ to include the proper
stack manipulations and emit the current lexical environment as part of every
state.
We think it is rather uninteresting to give the closed, elaborated definition
of $\semst{\wild}$ which necessarily gives up simplicity \sg{Give it in the Appendix}.
It is more interesting to see what other parts of the traces we can \emph{omit}
before compromising on expressivity and retain just as much information as
needed by the particular analysis we want to prove correct.

For example, in Control-Flow Analysis~\citep{Shivers:91}, we are ultimately
interested in observing the different lambda labels a variable occurrence might
evaluate to.
We do not need the lexical environment or the continuation stack, but the
call-by-need nature of our semantics needs the state.
That makes $\semst{\wild}$ a suitable concrete semantics for abstraction.
Yet for our usage analysis in \Cref{sec:problem}, we do not care so much
about the \emph{state} in which variable lookup happens, but rather about at
which \emph{address} the $\LookupT$ transition happened, as well as the $\BindT$
transition that tells us what $\mathbf{let}$ binding that particular address
refers to.

In this section, we will omit states --- including the explicitly maintained
heap --- altogether in favor of tracing the instantiations of transition rules,
called \emph{actions}.
The resulting \emph{stateless trace semantics} $\semless{\wild}$ is the
preferred framework of \citet{Cousot:21}, in which the heap will be
rematerialised as needed from the history of previous actions.

\begin{figure}
\[\begin{array}{c}
 \arraycolsep=3pt
 \begin{array}{rrclcl}
  \text{Action} & a & ∈ & \Actions & ::=  & \BindA(\px,\pa↦d) \mid \LookupA(\pa) \mid \UpdateA(\pa↦d) \\
                &   &   &          & \mid & \AppIA(d) \mid \AppEA(\px↦d) \mid \CaseIA(d) \mid \CaseEA(K,\many{\px↦d}) \\
 \end{array} \\
 \\[-0.5em]
 \arraycolsep=3pt
 \begin{array}{rrclcl@{\quad}rrclcl}
  \text{Initialisation trace} & ι        & ∈ & \ITraces                 & ::= & [a_1,...,a_n], n ∈ ℕ_0
  &
  \text{Delayed action}        & a^{\later} & ∈ & \later \Actions         &     &
  \\
  \text{Program trace}        & τ          & ∈ & \Traces        & ::= & \goodend{v} \mid \stuckend{} \mid a^{\later} \cons τ^{\later}
  &
  \text{Delayed trace}         & τ^{\later} & ∈ & \later \Traces &     &
  \\
  \text{Stateless domain}      & d          & ∈ & \MaxD                   & =   & \ITraces \to \Traces
  &
  \text{Delayed element}       & d^{\later} & ∈ & \later \MaxD            &     &
 \end{array} \\
 \\[-0.5em]
 \arraycolsep=3pt
 \begin{array}{rrclcl}
  \text{Stateless value} & v & ∈ & \MaxV & ::= & \FunV(f ∈ \later\MaxD \to \MaxD) \mid \ConV(K,\many{d^\later}^{α_K}) \\
 \end{array} \\
 \\[-0.5em]
 \begin{array}{rcl}
  \multicolumn{3}{c}{ \ruleform{
    \begin{array}{c}
      (\betastep) : \MaxD \to (\MaxV \pfun \MaxD) \to \MaxD \quad (\fcons) : \later\Actions \to \later\MaxD \to \MaxD \\
      μ : \ITraces \to \Addresses \pfun \MaxD \quad \ret : \MaxV \to \MaxD \\
      \deref : \Addresses \to \MaxD \quad \apply : \MaxD \to \MaxD \to \MaxD \\
      \select : \MaxD \to ((K:\Con) \to (\later\MaxD)^{α_K} \pfun \MaxD) \to \MaxD \\
    \end{array}
  }} \\
  \\[-0.5em]
  (d \betastep f)(ι_1) & = & \begin{cases}
    ι_2 \cons \idiom{f(v)(ι_1 \cons ι_2)} & \text{$d(ι_1) = ι_2 \cons \goodend{v}$ and $v ∈ \dom(f)$} \\
    ι_2 \cons \stuckend{} & \text{$d(ι_1) = ι_2 \cons \goodend{v}$ and $v \not∈ \dom(f)$} \\
    d(ι_1) & \text{otherwise} \\
  \end{cases} \\
  \\[-0.5em]
  (a^\later \fcons d^{\later})(ι)   & = & a^\later \cons \idiom{d^{\later}(ι \cons a^\later)} \\
  \\[-0.5em]
  μ(ι)(\pa) & = & \begin{cases}
    d & \text{if $ι = [..., \UpdateA(\pa↦d), ...]$} \\
    d & \text{if $ι = [..., \BindA(\px,\pa↦d), ...]$} \\
  \end{cases}  \\
  \\[-0.5em]
  \ret(v)(ι) & = & \goodend{v} \\
  \deref(\pa)(ι)   & = & (\idiom{\LookupA(\pa)} \fcons \idiom{μ(ι)(\pa)} \betastep \fn{v}{\idiom{\UpdateA(\pa↦\ret(v))} \fcons \idiom{\ret(v)}})(ι) \\
  \apply(d_\pe,d_\px) & = & d_\pe \betastep \fn{(\FunV(f))}{f(\idiom{d_\px})} \\
  \select(d,\mathit{alts}) & = & d \betastep \fn{(\ConV(K_s,\many{d_s^\later}))}{\idiom{\mathit{alts}(K_s, \many{d_s^\later})}} \text{ where } (K_s, \many{d_s^\later}) ∈ \dom(\mathit{alts}) \\
 \end{array} \\
 \\[-0.5em]
 \begin{array}{rcl}
  \multicolumn{3}{c}{ \ruleform{ \semless{\wild} \colon \Exp → (\Var \pfun \MaxD) → \MaxD } } \\
  \\[-0.5em]
  \semless{\px}_ρ       & = & \begin{cases}
    ρ(\px) & \px ∈ \dom(ρ) \\
    \fn{\wild}{\stuckend{}}  & \text{otherwise} \\
  \end{cases} \\
  \\[-0.5em]
  \semless{\Lam{\px}{\pe}}_ρ & = & \ret(\FunV(\fn{d^\later}{\idiom{\AppEA(\px↦d^\later)} \fcons \idiom{\semless{\pe}_{ρ[\px↦d^\later]}}})) \\
  \\[-0.5em]
  \semless{\pe~\px}_ρ   & = & \begin{cases}
    \idiom{\AppIA(ρ(x))} \fcons \idiom{\apply(\semless{\pe}_ρ, ρ(\px))} & \px ∈ \dom(ρ) \\
    \fn{\wild}{\stuckend{}}  & \text{otherwise} \\
  \end{cases} \\
  \\[-0.5em]
  \semless{\Let{\px}{\pe_1}{\pe_2}}_ρ(ι) & = &
    \begin{letarray}
      \text{let} & ρ' = ρ[\px ↦ \deref(\pa)] \quad \text{where $\pa \not∈ \dom(μ(ι))$} \\
      \text{in}  & (\idiom{\BindA(\px,\pa↦\semless{\pe_1}_{ρ'})} \fcons \idiom{\semless{\pe_2}_{ρ'}})(ι)
    \end{letarray} \\
  \\[-0.5em]
  \semless{K~\many{\px}}_ρ & = & \ret(\ConV(K,\idiom{\many{\semless{\px}_ρ}})) \\
  \\[-0.5em]
  \semless{\Case{\pe_s}{\Sel[r]}}_ρ & = &
    \begin{letarray}
      \text{let} & \mathit{alts} = \fn{K}{\fn{\many{d^\later}^{α_K}}{\idiom{\CaseEA(K,\many{\px↦d^\later})} \fcons \idiom{\semless{\pe_r}_{ρ[\many{\px↦d^\later}]}}}} \\
      \text{in} & \idiom{\CaseIA(\semless{\pe_s}_ρ)} \fcons \idiom{\select(\semless{\pe_s}_ρ, \mathit{alts})}  \\
    \end{letarray}
 \end{array} \\
\end{array}\]
\caption{Stateless Trace Semantics}
  \label{fig:semless}
\end{figure}

\subsection{Going stateless}

\Cref{fig:semless} gives the definition for the stateless trace semantics
$\semless{\wild}$.
The domain of stateless maximal traces $\MaxD$ maps a finite
\emph{initialisation trace} $ι$ to a possibly infinite or stuck program trace
$τ$ \emph{continuing} the initialisation trace.
The similarity to $\StateD$ is striking; initialisation traces replace
materialised heaps $μ$ in the stateful semantics.
As we shall see, the auxiliary function $\tilde{μ}$ (using tilde as before to disambiguate from the stateful semantics) can rematerialise the heap from $ι$.

The fundamental difference to the stateful semantics manifests in the
information encoded in a trace $τ$:
Instead of a sequence of states $σ$ there is a (possibly empty, if stuck)
sequence of \emph{actions} $a$.
With the exception of $\ValueA$ actions which we will explain in due course,
each kind of action corresponds to a transition rule in the LK semantics.
In fact, each action carries with it part of the ``closure'' of the
particular transition rule which is readily available for analysis.
For example, the $\LookupA$ action carries the heap address which is accessed,
$\BindA$ actions carry the $\mathsf{let}$-bound variable, its fresh address and
the denotation of the right-hand side.

Initialisation traces $ι$ are finite lists of actions and we often coerce freely
from and to finite program traces $τ$ that are not stuck (\eg, ending in
$\goodend{\wild}$).
For example, the concatenation of two initialisation traces $ι_1 \concat ι_2$ is
again an initialisation trace.
This is exploited in the auxiliary definition of the forward composition
operator $\fcomp$, which encodes sequential composition of two $\MaxD$
denotations, thus fulfilling a part of the role that $\betastep$ had in
\Cref{sec:stateful}.
The expression $d_1(ι) \concat ι$ is only well-defined as an initialisation
trace when $d_1(ι)$ is finite and not stuck (and thus an initialisation trace
itself).
This is indeed the case:
Note that $τ_1 \concat τ_2^\later$ will only look at $τ_2^\later$ when $τ_1$
is finite.
Applied to the definition of $\fcomp$, $d_1(ι) \concat ι$ is only evaluated when
$d_1(ι)$ is finite, so $\fcomp$ is well-defined.

We re-use the same greek letter as in \Cref{sec:stateful} and disambiguate as
needed, as before using tilde $\tilde{τ}$.

\begin{figure}
\[\begin{array}{rcl}
  α_\Environments(ρ) & = & \deref \circ ρ \\
  α_\Heaps([\many{\pa ↦ (ρ,\pe)}]) & = & [\many{\UpdateA(\pa ↦ \semst{\pe}_{α_\Environments(ρ)}}] \\
  α_\MaxV(ρ,\Lam{\px}{\pe}) & = & \FunV(\fn{d}{\idiom{\AppEA(\px↦d)} \fcons \idiom{\semless{\pe}_{α_\Environments(ρ)[\px↦d]}}}) \\
  α_\MaxV(ρ,K~\many{\px}) & = & \ConV(K,\idiom{\many{\semless{\px}_{α_\Environments(ρ)}}}) \\
  α_\Actions(σ) & = & \begin{cases}
    \BindA(\px,\pa↦\semless{\pe_1}_{α_\Environments(ρ[\px↦\pa])}) & σ = (\Let{\px}{\pe_1}{\wild},ρ,μ,\wild) \wedge \pa \not∈ \dom(μ) \\
    \AppIA(\deref(\pa)) & σ = (\wild~\px,ρ,\wild,\ApplyF(\pa) \pushF \wild) \\
    \CaseIA(\semless{\pe_s}_{α_\Environments(ρ)}) & σ = (\Case{\pe_s}{\wild},ρ,\wild, \wild)\\
    \LookupA(ρ(\px)) & σ = (\px,ρ,\wild,\UpdateF(\pa) \pushF \wild) \\
    \AppEA(\px↦\deref(\pa)) & σ = (\Lam{\px}{\wild},\wild,\wild,\ApplyF(\pa) \pushF \wild) \\
    \CaseEA(K',\many{\px_i ↦ \deref(ρ(\py))}) & σ = (K'~\many{\py}, ρ, \wild, \SelF(\wild,\Sel) \pushF \wild) \wedge K' = K_i \\
    \UpdateA(\pa↦\ret(α_\MaxV(ρ,\pv))) & σ = (\pv,ρ,\wild,\UpdateF(\pa) \pushF \wild) \\
  \end{cases} \\
  α_{\Traces}((σ_i)_{i∈\overline{n}},κ) & = & \begin{cases}
    \idiom{α_\Actions(σ_1)} \cons \idiom{α_{\Traces}((σ_{i+1})_{i∈\overline{n-1}},κ)} & n > 1 \\
    \goodend{α_\MaxV(ρ,\pv)} & n = 1 \wedge σ_1 = (\pv, ρ, \wild, κ) \\
    \stuckend{} & \text{otherwise} \\
  \end{cases} \\
  \mathcal{C} & = & ∀(σ_i)_{i∈\overline{n}}.\ \maxtrace{(σ_i)_{i∈\overline{n}}} \Longrightarrow ∀((\pe,ρ,μ,κ) = σ_1).\ α_{\Traces}((σ_i)_{i∈\overline{n}},κ) = \semst{\pe}_{α_\Environments(ρ)}(α_\Heaps(μ)) \\
\end{array}\]
\caption{Correctness predicate for $\semless{\wild}$}
  \label{fig:semless-correctness}
\end{figure}

\sg{Justify why we can't abstract $\semst{\wild}$ (where to take the address in the lookup case from?).
Although, perhaps we could; by zipping up the original heaps and stacks. But a direct proof is simpler.}

Similarly to before, we can define preservation lemmas:

\begin{lemma}[Preservation of length]
  \label{thm:abs-length-less}
  Let us define the length $\mathit{len} : \Traces \to ℕ_ω$ of a trace by
  guarded recursion
  \[
    \mathit{len}(τ) = \begin{cases}
      1 + \idiom{\mathit{len}(τ^{\later})} & τ = a^\later \cons τ^{\later} \\
      1 & \text{otherwise} \\
    \end{cases}
  \]
  Now let $(σ_i)_{i∈\overline{n}}$ be an arbitrary trace.
  Then $\mathit{len}(α_\STraces((σ_i)_{i∈\overline{n}},\cont(σ_1))) = n$.
\end{lemma}
\begin{proof}
  Similar to \Cref{thm:abs-length}.
\end{proof}

\begin{lemma}[Preservation of components]
  \label{thm:abs-components}
  Let $(σ_i)_{i∈\overline{n}}$ be a trace and let $τ = α_\Traces((σ_i)_{i∈\overline{n}},\cont(σ_1))$.
  Then for all $j∈\overline{n-1}$, $τ_j = α_\Actions(σ_j)$
  (where $τ_j$ denotes the $j$th action in $τ$)
  and if $τ$ ends in $\goodend{v}$, then $v = α_\MaxV(ρ,\pv)$, where $σ_n = (\pv, ρ, \wild, \wild)$.
\end{lemma}
\begin{proof}
  Similar to \Cref{thm:abs-states}.
\end{proof}

\begin{lemma}[Preservation of characteristic]
  \label{thm:abs-max-trace-less}
  Let $(σ_i)_{i∈\overline{n}}$ be a maximal trace.
  Then $α_\Traces((σ_i)_{i∈\overline{n}}, cont(σ_1))$ is ...
  \begin{itemize}
    \item ... infinite if and only if $(σ_i)_{i∈\overline{n}})$ is diverging
    \item ... ending with $\goodend{\wild}$ if and only if $(σ_i)_{i∈\overline{n}}$ is balanced
    \item ... ending with $\stuckend{\wild}$ if and only if $(σ_i)_{i∈\overline{n}}$ is stuck
  \end{itemize}
\end{lemma}
\begin{proof}
  Similar to \Cref{thm:abs-max-trace}.
\end{proof}

\begin{theorem}[Correctness of $\semless{\wild}$]
  \label{thm:semless-correct}
  $\mathcal{C}$ from \Cref{fig:semless-correctness} holds.
  That is, whenever $(σ_i)_{i∈\overline{n}}$ is a maximal LK trace with source
  state $(\pe,ρ,μ,κ)$, we have
  $α_{\Traces}((σ_i)_{i∈\overline{n}},κ) = \semst{\pe}_{α_\Environments(ρ)}(α_\Heaps(μ))$.
\end{theorem}
\begin{proof}
  Similar to \Cref{thm:semst-correct}. \sg{We probably want to carry out the proof explicitly.}
\end{proof}

Again, this allows us to prove a strong version of adequacy:

\begin{lemma}[Adequacy of $\semless{\wild}$]
  \label{thm:semless-adequate}
  Let $τ = \semless{\pe}_{[]}([])$.
  \begin{itemize}
    \item
      $τ$ ends with $\goodend{\wild}$ (is balanced) iff there exists a final
      state $σ$ such that $\inj(\pe) \smallstep^* σ$.
    \item
      $τ$ ends with $\stuckend{\wild}$ (is stuck) iff there exists a non-final
      state $σ$ such that $\inj(\pe) \smallstep^* σ$ and there exists no $σ'$
      such that $σ \smallstep σ'$.
    \item
      $τ$ is infinite (is diverging) iff for all $σ$ with $\inj(\pe)
      \smallstep^* σ$ there exists $σ'$ with $σ \smallstep σ'$.
  \end{itemize}
\end{lemma}
\begin{proof}
  Same as for \Cref{thm:semst-adequate}.
\end{proof}

It should be clear that $α_\Actions$ could elaborate the returned actions with
more information from the machine states without a noticable effect on the
correctness proof.
For example it could interleave the list of actions with program labels.
The only drawback of doing so would be that $\semless{\wild}$ becomes more
complicated.
The same applies to $α_\States$ from \Cref{sec:stateful} and $\semst{\wild}$, of
course, where this increase in complexity can be witnessed by having a look at
the generalisation in the Appendix \sg{Write that}.
