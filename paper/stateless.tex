\section{Stateless Semantics}
\label{sec:stateless}

\begin{figure}
\[\begin{array}{c}
 \arraycolsep=2pt
 \begin{array}{rrclcl}
  \text{Program point}   & \pp      & ∈ & \ProgramPoints        &  =         & \{ \return \} + \Exp \\
  \text{Actions}         & a        & ∈ & \Actions              & ::=        & \AppIA(d) \mid \AppEA(\px↦d) \mid \BindA(\px,\pa↦\pe,d) \\
                         &          &   &                       & \mid       & \LookupA(\pa) \mid \UpdateA(\pa) \mid \ValueA(v) \\
  \text{Finite Traces}   & τ^+      & ∈ & \Traces^+             & ::=        & \pp\trend \mid \pp \act{a} τ^+  \\
  \text{Finite and infinite Traces} & τ & ∈ & \Traces^{+\infty} & ::=_{\gfp} & \pp\trend \mid \pp \act{a} τ    \\
  \\
  \text{Domain of maximal traces} & d & ∈ & \MaxD   & = & \Traces^+ \to \Traces^{+\infty} \\
  \text{Stateless values}                   & v & ∈ & \Values{} & ::= & \FunV(f ∈ \MaxD \to \MaxD) \\
 \end{array} \\
 \\[-0.5em]
 \ruleform{alloc : \Traces^+ \to \Addresses} \quad \text{an injective function on the number of $\BindA$ actions in the trace} \\
 \\
 \begin{array}{rcl}
  \multicolumn{3}{c}{ \ruleform{ src(τ) = \pp \qquad tgt(τ) = \pp } } \\
  \\[-0.5em]
  src(\pp\trend)     & = & \pp \\
  src(\pp \act{a} τ) & = & \pp \\
  \\[-0.5em]
  tgt(τ)    & = & \begin{cases}
    undefined & \text{if $τ$ infinite} \\
    \pp       & \text{if $τ = ... \act{a} \pp\trend$}
  \end{cases} \\
 \end{array} \quad
 \begin{array}{rcl}
  \multicolumn{3}{c}{ \ruleform{ τ_1 \concat τ_2 = τ_3 \qquad τ_1 \subtrceq τ_2 } } \\
  \\[-0.5em]
  τ_1 \concat τ_2 & = & \begin{cases}
    \pp \act{a} (τ_1' \concat τ_2) & \text{if $τ_1 = \pp \act{a} τ_1'$} \\
    τ_2                     & \text{if $τ_1 = \pp\trend$ and $src(τ_2) = \pp$} \\
    undefined               & \text{if $τ_1 = \pp\trend$ and $src(τ_2) \not= \pp$} \\
  \end{cases} \\
  \\[-0.5em]
  τ_s \subtrceq τ & = & \exists τ_1, τ_2.\ (τ = τ_1 \concat τ_s \concat τ_2)  \\
 \end{array} \\
 \\
 \begin{array}{c}
  \ruleform{ \getval{τ^+}{(\pv,v)} } \\
  \\[-0.5em]
  \inferrule*[right=\textsc{ValVal}]
    {\quad}
    {\getval{τ^{+} \act{} \pv \act{\ValueA(v)} \return\trend}{(\pv,v)}}
  \quad
  \inferrule*[right=\textsc{ValUpd}]
    {\getval{τ^+}{(\pv,v)}}
    {\getval{τ^{+} \act{\UpdateA(\wild)} \return\trend}{(\pv,v)}}
  \\[-0.5em]
 \end{array}
\end{array}\]
\caption{Syntax of stateless traces}
  \label{fig:stateless-syntax}
\end{figure}


\subsection{Going stateless}

In the previous section, we gave a compositional trace-based semantics and
proved it adequate wrt. the LK machine semantics the traces of which it
generates. With compositionality and structural induction we recover a strong
advantage of denotational semantics.

Unfortunately, it is still ergonomically lacking in the following ways:

\begin{enumerate}
  \item
    In contrast to $\semscott{\wild}$, the lexical environment $ρ$ is buried in
    the states of the generated traces (thus manipulated as ``data'') rather
    than reflected into a parameter (``code'') of $\semst{\wild}$.
    That makes it awkward to express properties of free variables in terms of
    the semantics such as done in our notion of deadness \Cref{defn:deadness}.

  \item
    Similarly, the continuation stack (data) seems largely redundant with the
    meta-level call stack of $\semst{\wild}$.

  \item
    In a trace $τ = \semst{\pe}(σ)$, the interesting information is not so much
    encoded in the states but in the particular instance of transition rule
    taken. Furthermore, often it is not enough to regard the states in isolation
    but also the transition taken.

    In light of this, it would be consequent to rematerialise the heap $μ$ on
    the fly from the history of previous transitions, so that the only remaining
    information attached to a state becomes its label and whether or not it is a
    return state (which can be regarded as a special label).
    The result is a (more explicitly) \emph{labelled} transition system%
    \footnote{Here, the use of ``label'' refers to the name of the transition
    rule rather than the labelling of expressions.},
    in which the transitions carry the bulk of the meaning.
\end{enumerate}

A \emph{stateless trace semantics} alluded to in the last point is the preferred
framework of \citet{Cousot:21}, for example. We shall follow suit and provide a
stateless maximal prefix trace semantics in the style of Cousot in
\Cref{fig:seminf}.

\Cref{fig:stateless-syntax} provides the new syntactic building blocks of the
semantics. A \emph{program point} $\pp$ is either a return point $\return$ or a
labelled expression; each program point defines one of finitely many
control-flow nodes of the program. Actions $a$ correspond one-to-one to the
transition rules of the LK machine, only they are now retained in an AST-like
fashion in the trace instead of eliminated (via functions $app_1$, $app_2$,
$bind$, \etc) to produce the successor state. Stateless traces $τ$ carry the
the transition taken as an action $a$. We re-use the same greek letter as in
\Cref{sec:semantics} and disambiguate as needed. We consider inductively-defined
finite traces $τ^+$ a subtype of the potentially infinite and thus
coinductively-defined traces $τ$.

Comparing the domain of maximal traces with the one for LK traces from
\Cref{fig:lk-domain}, we can see that a finite \emph{initialisation trace} takes
the place of the initial state as a parameter to a domain element $d$.
Similarly, the use of $\Addresses$ in the definition of semantic values $v$ is
replaced in favor of a seemingly more complex argument of type $\MaxD$; in
practice the $d$ passed will be one-to-one to the address passed in the stateful
semantics.

\begin{figure}
\[\begin{array}{c}
 \begin{array}{rcl}
  \multicolumn{3}{c}{ \ruleform{ \seminf{\wild} \colon \Exp → (\Var \pfun \MaxD) → \MaxD } } \\
  \\[-0.5em]
  stuck(τ_i^+)   & = & tgt(τ_i^+)\trend \\
  \\[-0.5em]
  \stepm{p}{a}{\pp}(τ_i^+) & = &
    \ternary{\text{$tgt(τ_i^+)$ matches $p$}}
            {tgt(τ_i^+) \act{a} \pp\trend}
            {tgt(τ_i^+)\trend} \\
  \\[-0.5em]
  (d_1 \fcomp d_2)(τ_i^+)   & = &
    \ternary{d_1(τ_i^+) = tgt(τ_i^+)\trend}
            {tgt(τ_i^+)}
            {d_1(τ_i^+) \concat d_2(τ_i^+ \concat d_1(τ_i^+))} \\
  \\[-0.5em]
  apply(d_\px)(τ_\pe^+)   & = & \begin{cases}
    f(d_\px)(τ_\pe^+) & \text{if $\getval{τ_\pe^+}{(\wild,\FunV(f))}$}  \\
    stuck(τ_\pe^+) & \text{otherwise}  \\
  \end{cases} \\
  \\[-0.5em]
  μ(τ_i^+)(\pa) & = & \begin{cases}
    (\pv, \stepm{\pv}{\ValueA(v)}{\return}) & \text{if $τ_{\pv} \act{\UpdateA(\pa)} \return \trend \subtrceq τ_i^+$ and $\getval{τ_{\pv}}{(\pv,v)}$} \\
    (\pe, d) & \text{if $\wild \act{\BindA(\px,\pa↦\pe,d)} \wild\, \trend \subtrceq τ_i^+$} \\
  \end{cases}  \\
  \\[-0.5em]
  deref(\pa)(τ_i^+)   & = & (\step{\LookupA(\pa)}{\pe} \fcomp d \fcomp \stepm{\return}{\UpdateA(\pa)}{\return})(τ_i^+) \text{ where $(\pe,d) = μ(τ_i^+)(\pa)$} \\
  \\[-0.5em]
  \seminf{\pe}_ρ    (τ_i^+)   & = & undefined \qquad \text{if $tgt(τ_i^+) \not= \pe$} \\
  \\[-0.5em]
  \seminf{\px}_ρ              & = & \ternary{\px ∈ \dom(ρ)}{ρ(\px)}{stuck} \\
  \\[-0.5em]
  \seminf{\Lam{\px}{\pe}}_ρ & = &
    \begin{letarray}
      \text{let} & f = d ↦ \stepm{\return}{\AppEA(\px↦d)}{\pe} \fcomp \seminf{\pe}_{ρ[\px↦d]} \\
      \text{in}  & \step{\ValueA(\FunV(f))}{\return} \\
    \end{letarray} \\
  \\[-0.5em]
  \seminf{\pe~\px}_ρ & = & \ternary{\px ∈ \dom(ρ)}{\step{\AppIA(ρ(x))}{\pe} \fcomp \seminf{\pe}_ρ \fcomp apply(ρ(\px))}{stuck} \\
  \\[-0.5em]
  \seminf{\Let{\px}{\pe_1}{\pe_2}}_ρ(τ_i^+) & = &
    \begin{letarray}
      \text{let} & \pa = alloc(τ_i^+) \\
                 & ρ' = ρ[\px ↦ deref(\pa)] \\
      \text{in}  & (\step{\BindA(\px,\pa↦\pe_1,\seminf{\pe_1}_{ρ'})}{\pe_2} \fcomp \seminf{\pe_2}_{ρ'})(τ_i^+)
    \end{letarray} \\
 \end{array} \\
\end{array}\]
\caption{Stateless Maximal Trace Semantics}
  \label{fig:seminf}
\end{figure}

Trace of the expression:
\[
\begin{array}{r@{}l}
   \multicolumn{2}{c}{\slbln{1}\Let{x}{\slbln{2}(\Lam{y}{\slbln{3}y})\slbln{4}}{\slbln{5}(\slbln{6}(\slbln{7}x~x)~x)}} \\
   \\
   \lbln{1} & \act{\BindA} \lbln{5} \act{\AppIA} \lbln{6} \act{\AppIA} \lbln{7} \\
            & \act{\LookupA} \lbln{2} \act{\ValueA(\FunV(f))} \lbln{4} \act{\AppEA} \lbln{3} \\
            & \act{\LookupA} \lbln{2} \act{\ValueA(\FunV(f))} \lbln{4} \act{\AppEA} \lbln{3} \\
            & \act{\LookupA} \lbln{2} \act{\ValueA(\FunV(f))} \lbln{4}
\end{array}
\]

% Note [Design of Maximal Trace Semantics]
% ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
% A stateless (prefix) trace semantics' defining feature is the absence of
% full-blown configurations between actions. However, states can be
% reconstructed from looking at the history of actions in the initialisation
% trace. So it is quite vital that the actions carry enough information.
%
% The need for a value action
% ---------------------------
% Values have after labels, so that when we reach at(v) we make one value
% transition to announce the value of at(v) in the trace. Without this
% action, it would be hard to differentiate between stuck and successful
% maximal traces. Furthermore, it plays a crucial role in the memoisation
% mechanism, where we reconstruct the memoised value from the trace.
%
% The need for an update action
% -----------------------------
% Memoisation could well work by looking for a balanced sub-trace in the
% initialisation trace that started with look(τ_k). In fact, earlier
% versions did exactly that, and it worked great!
% Unfortunately, it has the following drawbacks:
%   * CESK semantics does have update frames and we want to match those
%     rather simply. It is a matter of producing "complete" states, see
%     "Which info do we need to attach to an action?"
%   * We need to define relatively early what a balanced trace is.
%     The semantics itself should not depend on that...
%   * It is simpler to define the abstraction to stateful prefix trace semantics
%     when there are corresponding update actions
%   * It is better to be explicit to announce exactly when "the heap binding
%     changes" for the perspective of weak memory models and interleavings of
%     parallel traces (TODO: Read up on that!), which is one of the prime
%     reasons to consider stateless trace semantics in the first place.
%
% Why is the stateless semantics not simply (V, T+ -> T+∞)?
% ---------------------------------------------------------
% ... and in the process could abandon the value action (if we were willing
% to detect stuckness by looking at V)?
%
% Because then we can't see the prefix T+ when we have to extend ρ at let
% bindings. But this is our primary mechanism for sharing! Similarly for
% call-by-value.
%
% So we are stuck with value actions. Still, we could decide to return the
% value "out of band", in a pair, T+ -> (V, T+∞). That yields the worse of
% both worlds; the definition is similar to T+ -> T+∞ but we often need to
% adjust the second component of the pair; plus, in `memo`, we still have
% to "execute" the semantics S for its value, because we can't recover it
% from the trace.
%
% Which info do we need to attach to an action?
% ---------------------------------------------
% TLDR; that is determined by transition semantics that we want to
% be to abstract a trace into. The reasoning is as follows:
%
%   * "The transition semantics" is really the semantics we get by
%     applying the transition abstraction α_τ to a *stateful* trace
%     semantics, where the states capture enough information for
%     the resulting transition system to become deterministic.
%     (The transition system we get by abstracting the *stateless* trace
%     semantics isn't very useful precisely for that reason; taking
%     labels as state yields too many spurious transitions.)
%   * So determinism of the abstracted transition system is a quality
%     of the semantic richness of states (given that the sequence of states
%     is fixed); let's call state structure that allows for deterministic
%     abstraction "complete"
%   * (Are all complete state structures isomorph? Probably not)
%   * The stateful trace semantics is an abstraction of the stateless trace
%     semantics by way of α_S. We want to produce (at least one) stateful
%     semantics where the state space is complete. To produce such states, the
%     necessary information must be part of the stateless trace, otherwise we
%     can't write the abstraction function from stateless to stateful.
%
% So given the completeness of the states produced by α_S as a goal, we can
% make the following claims for action kinds in a trace:
%
%   * AppI, AppE, Lookup, Bind are all necessary actions because they make
%     a step from one label to a label of a subexpression.
%   * Val actions are the trace semantics' means of communicating a successful
%     (e.g., not stuck) execution as well as playing the role of `Just value`.
%     They correspond to Val transtitions in CESK or STG's ReturnCon
%   * We do *not* strictly need Update actions -- we just need update frames
%     in the stateful trace, but those could be reconstructed from when a
%     Lookup's balanced trace ended. Update actions make our life simpler in
%     other ways, though: See "The need for an update action".
%
% In fact, given that each action corresponds to a CESK transition, α_S can be
% defined inductively (by prefixes) on actions and states:
%
%   * The data on actions is simply erased and the corresopnding CESK transition
%     is taken. (Vital to realise that a well-formed stateless trace results in
%     an ok stateful trace.)
%   * For the state after prefix τ, we simply call \varrho(τ). It is a function
%     that Cousot uses throughout his book, and so should we.
%
% Now as to what information we need on the actions:
%
%   * AppI: We need the Var so that α_S can produce an Apply frame
%   * AppE: We need both the Var *and* the D so that varrho can produce the
%           proper environment.
%   * Lookup: We need the address so that we can push an update frame in α_S.
%             Also we need it to find the corresponding Bind.
%   * Bind: We need the address, so α_S can find it when encountering a Lookup
%           at that address. Then we also need the Var and the D for varrho.
%   * Update: The address is convenient (as are update actions to begin with),
%             otherwise we'd have to fiddle with balanced traces in memo to find
%             the corresponding Lookup.
%   * Values: It is convenient to attach values to Val actions; this is not strictly
%     necessary, just convenient. (See page 4 of 61e6f8a, quite ugly.)

\subsection{Abstraction}

% 1. Move Lookup into Env; have Env = Name :-> D and let its action look into
%    the Heap. Requires a bit of tricky setup in let_
% 2. Move the Env to meta level
% 3. Realise that we can now get rid of the stack, since everything happens
%    on the meta call stack
% 4. Materialise the state as needed during memo

\begin{figure}
\[\begin{array}{rcl}
  μ_ρ(τ)(\pa) & = & \begin{cases}
    \varrho(τ_1) & \text{if $τ_1 \act{\UpdateA(\pa)} \return \concat τ_2 = τ$} \\
    \varrho(τ_1 \act{\BindA(\px,\pa↦\pe,d)} \pp) & \text{if $τ_1 \act{\BindA(\px,\pa↦\pe,d)} \pp \concat τ_2 = τ$} \\
  \end{cases}  \\
  \varrho(τ \act{\BindA(\px,\pa↦\pe,d)} \pp\trend)(\px) & = & deref(\pa) \\
  \varrho(τ \act{\AppEA(\px↦d)} \pp\trend)(\px) & = & d \\
  \varrho(τ \act{\LookupA(\pa)} \pp\trend)(\px) & = & μ_ρ(τ)(\pa)(\px) \\
  \varrho(τ \act{a} \pp\trend)(\px) & = & \varrho(τ)(\px) \\
\end{array}\]
\caption{Materialising heap and environment from an initialisation trace}
  \label{fig:materialisation}
\end{figure}

\begin{figure}
\[\begin{array}{c}
 \begin{array}{rcl}
  \multicolumn{3}{c}{ \ruleform{ α^{\States} : ((\Var \pfun \MaxD) \to \MaxD) \to \StateD } } \\
  \\[-0.5em]
  deref^{-1}(d) & = & \pa \text{ such that $d = deref(\pa)$} \\
  tgt_\States^{-1}(σ) & = & τ \text{ such that $\validtrace{τ}$ and $tgt_\States(τ) = σ$} \\
  \\[-0.5em]
  α_{\STraces}(τ_i^+, \pp\trend) & = & α_{\States}(τ_i^+ \concat \pp\trend)\trend \\
  α_{\STraces}(τ_i^+, τ \act{a} \pp\trend) & = & α_{\STraces}(τ_i^+,τ); α_{\States}(τ_i^+ \concat τ \act{a} \pp\trend)\trend \\
  α_{\States}(τ) & = & (α_{\Control}(τ,tgt(τ)), α_{\Environments}(\varrho(τ)), α_{\Heaps}(τ) \circ μ(τ), α_{\Continuations}(τ)) \\
  α_{\Control}(τ, \return) & = & (\pv,α_{\StateV}(v)) \text{ where $\getval{τ}{(\pv,v)}$} \\
  α_{\Control}(τ, \pe) & = & \pe \\
  α_{\Environments}(ρ) & = & deref^{-1} \circ ρ \\
  α_{\Heaps}(τ)([\many{\pa ↦ (\pe,d)}]) & = & [\many{\pa ↦ (\pe, μ_ρ(τ)(\pa), α_{\StateD}(d))}] \\
  α_{\Continuations}(\pp\trend) & = & \StopF \\
  α_{\Continuations}(τ \act{\LookupA(\pa)} \pp\trend) & = & \UpdateF(\pa) \pushF α_{\Continuations}(τ) \\
  α_{\Continuations}(τ \act{\UpdateA(\pa)} \pp\trend) & = & κ \text{ where $α_{\Continuations}(τ) = \UpdateF(\pa) \pushF κ$} \\
  α_{\Continuations}(τ \act{\AppIA(d)} \pp\trend) & = & \ApplyF(deref^{-1}(d)) \pushF α_{\Continuations}(τ) \\
  α_{\Continuations}(τ \act{\AppEA(\px↦d)}   \pp\trend) & = & κ \text{ where $α_{\Continuations}(τ) = \ApplyF(deref^{-1}(d)) \pushF κ$} \\
  α_{\Continuations}(τ \act{} \pp\trend) & = & α_{\Continuations}(τ) \\
  α_{\StateD}(d) & = & (\fn{τ}{α_{\STraces}(τ,d(τ))) \circ γ_{\STraces} \circ tgt_\States^{-1}} \\
  α_{\StateV}(\FunV(f)) & = & \FunV(α_{\StateD} \circ f \circ deref) \\
  γ_{\StateD}(d) & = & γ_{\STraces} \circ d \circ tgt_\States \circ α_{\STraces} \\
  γ_{\StateV}(\FunV(f)) & = & \FunV(γ_{\StateD} \circ f \circ deref^{-1}) \\
  γ_{\STraces}(σ\trend) & = & γ_{\States}(σ)\trend \\
  γ_{\STraces}(τ; σ\trend) & = & γ_{\STraces}(τ) \act{γ_{\Actions}(tgt_\States(τ) \smallstep σ)} γ_{\States}(τ; σ\trend)\trend \\
  γ_{\States}(γ,\wild,\wild,\wild) & = & α_{\Control}(γ) \\
  γ_{\Control}((\pv,v)) & = & \return \\
  γ_{\Control}(\pe) & = & \pe \\
  γ_{\Actions}(\BindT(\px,\pa,\pe_1,d)) & = & \BindA(\px,\pa↦\pe_1,γ_{\StateD}(d)) \\
  γ_{\Actions}(\UpdateT(\pa)) & = & \UpdateA(\pa) \\
  γ_{\Actions}(\LookupT(\pa)) & = & \LookupA(\pa) \\
  γ_{\Actions}(\AppIT(\pa)) & = & \AppIA(deref(\pa)) \\
  γ_{\Actions}(\AppET(\px,\pa)) & = & \AppEA(\px,deref(\pa)) \\
  γ_{\Actions}(\ValueT(\pv,v)) & = & \ValueA(\pv,γ_{\StateV}(v)) \\
  \\
 \end{array}
\end{array}\]
\caption{Prefix Trace Abstraction}
  \label{fig:semantics}
\end{figure}

\begin{figure}
\[
\begin{array}{ll}
  & \text{Let } ρ_x = \lfp(λρ. [x ↦ cons(\LookupA,\lbln{2}],\seminf{\slbln{2}(\Lam{y}{\slbln{3}y})\slbln{4}}_ρ) \\
  & \text{and } ρ_{x,y} = ρ_x[y ↦ ρ_1(x)] \\
  & \text{and } f = d ↦ cons(\AppEA,\lbln{3},\seminf{\slbln{3}y}_{ρ[y↦d]}) \\
  & \text{Evaluate }\slbln{1}\Let{x}{\slbln{2}(\Lam{y}{\slbln{3}y})\slbln{4}}{\slbln{5}(\slbln{6}(\slbln{7}x~x)~x)} \\
  & \\
  & \seminf{\slbln{1}\Let{x}{\slbln{2}(\Lam{y}{\slbln{3}y})\slbln{4}}{\slbln{5}(\slbln{6}(\slbln{7}x~x)~x)}}_\bot(\lbln{1}) \\
  & \\[-0.9em]
  ⇒ & \lbln{1} \act{\BindA} \seminf{\slbln{5}(\slbln{6}(\slbln{7}x~x)~x)}_{ρ_x}(\lbln{1} \act{\BindA} \lbln{5}) \\
  & \\[-0.9em]
  ⇒ & \lbln{1} \act{\BindA} \lbln{5} \act{\AppIA} \seminf{\slbln{6}(\slbln{7}x~x)}_{ρ_x}(\lbln{1} \act{\BindA} \lbln{5} \act{\AppIA} \lbln{6}) \\
  & \\[-0.9em]
  ⇒ & \lbln{1} \act{\BindA} \lbln{5} \act{\AppIA} \lbln{6} \act{\AppIA} \seminf{\slbln{7}x}_{ρ_x}(\overbrace{\lbln{1} \act{\BindA} \lbln{5} \act{\AppIA} \lbln{6} \act{\AppIA} \lbln{7}}^{τ_1}) \\
  & \\[-0.9em]
  ⇒ & τ_1 \act{\LookupA} \seminf{\slbln{2}(\Lam{y}{\slbln{3}y})\slbln{4}}_{ρ_x}(τ_1 \act{\LookupA} \lbln{2}) \\
  & \\[-0.9em]
  ⇒ & τ_1 \act{\LookupA} \lbln{2} \act{\ValueA(\FunV(f))} f(ρ_x(x))(τ_1 \act{\LookupA} \lbln{2} \act{\ValueA(\FunV(f))} \lbln{4}) \\
  & \\[-0.9em]
  ⇒ & τ_1 \act{\LookupA} \lbln{2} \act{\ValueA(\FunV(f))} \lbln{4} \act{\AppEA} \seminf{\slbln{3}y}_{ρ_{x,y}}(\overbrace{τ_1 \act{\LookupA} \lbln{2} \act{\ValueA(\FunV(f))} \lbln{4} \act{\AppEA} \lbln{3}}^{τ_2}) \\
  & \\[-0.9em]
  ⇒ & τ_2 \act{\LookupA} \seminf{\slbln{2}(\Lam{y}{\slbln{3}y})\slbln{4}}_{ρ_x}(τ_2 \act{\LookupA} \lbln{2}) \\
  & \\[-0.9em]
  ⇒ & τ_2 \act{\LookupA} \lbln{2} \act{\ValueA(\FunV(f))} f(ρ_x(x))(τ_2 \act{\LookupA} \lbln{2} \act{\ValueA(\FunV(f))} \lbln{4}) \\
  & \\[-0.9em]
  ⇒ & τ_2 \act{\LookupA} \lbln{2} \act{\ValueA(\FunV(f))} \lbln{4} \act{\AppEA} \seminf{\slbln{3}y}_{ρ_{x,y}}(\overbrace{τ_2 \act{\LookupA} \lbln{2} \act{\ValueA(\FunV(f))} \lbln{4} \act{\AppEA} \lbln{3}}^{τ_3}) \\
  & \\[-0.9em]
  ⇒ & τ_3 \act{\LookupA} \seminf{\slbln{2}(\Lam{y}{\slbln{3}y})\slbln{4}}_{ρ_x}(τ_3 \act{\LookupA} \lbln{2}) \\
  & \\[-0.9em]
  ⇒ & τ_3 \act{\LookupA} \lbln{2} \act{\ValueA(\FunV(f))} \lbln{4} \\
  & \\[-0.9em]
  & \\
  = \lbln{1} & \act{\BindA} \lbln{5} \act{\AppIA} \lbln{6} \act{\AppIA} \lbln{7} \\
             & \act{\LookupA} \lbln{2} \act{\ValueA(\FunV(f))} \lbln{4} \act{\AppEA} \lbln{3} \\
             & \act{\LookupA} \lbln{2} \act{\ValueA(\FunV(f))} \lbln{4} \act{\AppEA} \lbln{3} \\
             & \act{\LookupA} \lbln{2} \act{\ValueA(\FunV(f))} \lbln{4}
\end{array}
\]
\caption{Evalation of $\seminf{\wild}$}
\end{figure}

\begin{figure}
\[\begin{array}{c}
 \begin{array}{rrclcl}
  \text{Constructors} &     K & ∈ & \Con     & \subseteq & \Nat \\
  \text{Expressions}  &   \pe & ∈ & \Exp     & ::=       & \ldots \mid K~\many{\px} \mid \Case{\pe}{\Sel} \\
  \\
  \text{Actions}      &     a & ∈ & \Actions & ::=       & \ldots \mid \CaseIA \mid \CaseEA \\
  \text{Values}       &     v & ∈ & \Values{}  & ::=       & \ldots \mid \ConV(\Sigma_{K ∈ \Con}(\Pi_{i=1}^{A_K}d_i)) \text{ where $K$ has $A_K$ fields} \\
 \end{array} \\
 \\
  \ruleform{ \balanced{τ} } \\
  \\[-0.5em]
  \inferrule*[right=\textsc{BalCase}]
    {\balanced{τ_1}\quad\balanced{τ_2}}
    {\balanced{\lbl \act{\CaseIA} τ_1 \act{\CaseEA} τ_2}} \\
 \\
 \begin{array}{rcl}
  \multicolumn{3}{c}{ \ruleform{ \seminf{\wild} \colon \Exp → (\Var → \MaxD) → \MaxD } } \\
  \\[-0.5em]
  \seminf{K~\many{\px}}_ρ(τ_i^+) & = & K~\many{\px} \act{\ValueA(\ConV(K,\many{ρ(\px)}))} \return \\
  \\[-0.5em]
  \seminf{\Case{\pe_s}{\Sel}}_ρ(τ_i^+) & = & τ_s \concat \begin{cases}
      Rhs(K,\many{d})(τ_i^+ \concat τ_s) & \text{if $\getval{τ_s}{\ConV(K,\many{d})}$}  \\
      stuck(τ_i^+ \concat τ_s) & \text{otherwise}  \\
    \end{cases} \\
    & & \text{where} \begin{array}{lcl}
                       τ_s & = & cons( \CaseIA, \pe_s,\seminf{\pe_s}_ρ)(τ_i^+) \\
                       Rhs(K,\many{d}) & = & cons(\CaseEA,\pe_K,\seminf{\pe_K}_{ρ[\many{\px↦d}]}) \\
                     \end{array} \\
  \\
 \end{array} \\
\end{array}\]
\caption{Algebraic data types in Structural Maximal Trace Semantics}
  \label{fig:semantics}
\end{figure}
